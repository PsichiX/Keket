<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Asset Protocol - Keket - Asset Database on top of ECS</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "ayu";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Keket - Asset Database on top of ECS</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="asset-protocol"><a class="header" href="#asset-protocol">Asset Protocol</a></h1>
<p>Asset protocols are units that decode bytes and then does some things with decoded
data, usually put components into asset, schedule dependencies to load and relate
them with source asset, if there are any dependencies.</p>
<p>Asset protocols are second step in asset progression - they are decoupled from
asset fetch engines to make them not care about source of the asset and by that
be used no matter where assets come from, which solves the need for asset loaders
to implement with all possible asset sources, which is cumbersome to deal with.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        // Asset protocols tell how to deserialize bytes into assets.
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Bundle protocol allows for easly making a protocol that takes
        // bytes and returns bundle with optional dependencies.
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        // Asset fetch tells how to get bytes from specific source.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!(
            "Asset: `{}` at location: {:?} has metadata: {:#?}",
            asset_path, file_path, metadata
        );
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>For type to be considered asset protocol, it must implement <code>AssetProtocol</code> trait
that has methods for processing asset bytes:</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPathStatic},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::bundle::{
</span><span class="boring">        BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Register custom asset processor.
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("custom", CustomAssetProcessor))
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span><span class="boring">    // Ensure custom asset existence.
</span><span class="boring">    let handle = database.ensure("custom://part1.json")?;
</span><span class="boring">
</span><span class="boring">    // Make database process loaded dependencies.
</span><span class="boring">    while database.is_busy() {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
</span><span class="boring">    println!("Custom chain contents: {:?}", contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Custom asset type.
</span><span class="boring">#[derive(Debug, Default, Deserialize)]
</span><span class="boring">struct CustomAsset {
</span><span class="boring">    // Main content.
</span><span class="boring">    content: String,
</span><span class="boring">    // Optional sibling asset (content continuation).
</span><span class="boring">    #[serde(default)]
</span><span class="boring">    next: Option&lt;AssetPathStatic&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomAsset {
</span><span class="boring">    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
</span><span class="boring">        // Read this and it's siblings content to output.
</span><span class="boring">        let mut result = String::new();
</span><span class="boring">        let mut current = Some(self);
</span><span class="boring">        while let Some(asset) = current {
</span><span class="boring">            result.push_str(asset.content.as_str());
</span><span class="boring">            current = current
</span><span class="boring">                .as_ref()
</span><span class="boring">                .and_then(|asset| asset.next.as_ref())
</span><span class="boring">                .and_then(|path| path.find(database))
</span><span class="boring">                .and_then(|handle| handle.access_checked::&lt;&amp;Self&gt;(database));
</span><span class="boring">            if current.is_some() {
</span><span class="boring">                result.push(' ');
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomAssetProcessor;

impl BundleWithDependenciesProcessor for CustomAssetProcessor {
    // Bundle of asset components this asset processor produces from processed asset.
    type Bundle = (CustomAsset,);

    fn process_bytes(
        &amp;mut self,
        bytes: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;
        let dependency = asset.next.clone();
        // Return bundled components and optional dependency which will be additionally loaded.
        Ok(BundleWithDependencies::new((asset,)).maybe_dependency(dependency))
    }
}</code></pre>
<p>Optionally type can implement more specific asset processing that doesn't assume
you only care about bytes or even only processed asset:</p>
<pre><code class="language-rust ignore"><span class="boring">use anput::world::World;
</span><span class="boring">use keket::{
</span><span class="boring">    database::{
</span><span class="boring">        AssetDatabase,
</span><span class="boring">        handle::{AssetDependency, AssetHandle},
</span><span class="boring">        path::AssetPathStatic,
</span><span class="boring">    },
</span><span class="boring">    fetch::{AssetAwaitsResolution, AssetBytesAreReadyToProcess, file::FileAssetFetch},
</span><span class="boring">    protocol::AssetProtocol,
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Register custom asset protocol.
</span><span class="boring">        .with_protocol(CustomAssetProtocol)
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"))
</span><span class="boring">        .with_event(|event| {
</span><span class="boring">            println!("Asset closure event: {:#?}", event);
</span><span class="boring">            Ok(())
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">    let handle = database.ensure("custom://part1.json")?;
</span><span class="boring">
</span><span class="boring">    while database.is_busy() {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
</span><span class="boring">    println!("Custom chain contents: {:?}", contents);
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Custom asset type.
</span><span class="boring">#[derive(Debug, Default, Deserialize)]
</span><span class="boring">struct CustomAsset {
</span><span class="boring">    content: String,
</span><span class="boring">    #[serde(default)]
</span><span class="boring">    next: Option&lt;AssetPathStatic&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomAsset {
</span><span class="boring">    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
</span><span class="boring">        let mut result = String::new();
</span><span class="boring">        let mut current = Some(self);
</span><span class="boring">        while let Some(asset) = current {
</span><span class="boring">            result.push_str(asset.content.as_str());
</span><span class="boring">            current = current
</span><span class="boring">                .as_ref()
</span><span class="boring">                .and_then(|asset| asset.next.as_ref())
</span><span class="boring">                .and_then(|path| path.find(database))
</span><span class="boring">                .and_then(|handle| handle.access_checked::&lt;&amp;Self&gt;(database));
</span><span class="boring">            if current.is_some() {
</span><span class="boring">                result.push(' ');
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomAssetProtocol;

impl AssetProtocol for CustomAssetProtocol {
    fn name(&amp;self) -&gt; &amp;str {
        "custom"
    }

    fn process_asset_bytes(
        &amp;mut self,
        handle: AssetHandle,
        storage: &amp;mut World,
    ) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        // Always remember that in order for asset to be considered done with processing
        // bytes, it has to remove AssetBytesAreReadyToProcess component from that asset.
        // We are doing that by taking its bytes content first and removing it after.
        let bytes = {
            let mut bytes =
                storage.component_mut::&lt;true, AssetBytesAreReadyToProcess&gt;(handle.entity())?;
            std::mem::take(&amp;mut bytes.0)
        };
        storage.remove::&lt;(AssetBytesAreReadyToProcess,)&gt;(handle.entity())?;

        // Once we have asset bytes, we decode them into asset data.
        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;

        // We also have to extract dependencies if it has some.
        if let Some(path) = asset.next.clone() {
            // For every dependency we get, we need to spawn an asset entity with
            // AssetAwaitsResolution component to tell asset database to start loading it.
            let entity = storage.spawn((path, AssetAwaitsResolution))?;

            // We should also relate processed asset with its dependency asset.
            // Dependency relations are useful for traversing asset graphs.
            storage.relate::&lt;true, _&gt;(AssetDependency, handle.entity(), entity)?;
        }

        storage.insert(handle.entity(), (asset,))?;
        Ok(())
    }
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../fetch/client.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../protocol/bytes.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../fetch/client.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../protocol/bytes.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
