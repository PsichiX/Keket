<!DOCTYPE HTML>
<html lang="en" class="ayu sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Keket - Asset Database on top of ECS</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "ayu";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Keket - Asset Database on top of ECS</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <code>Keket</code>!</p>
<p>Modern, flexible, modular Asset Management library built on top of ECS as its
storage.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        // Asset protocols tell how to deserialize bytes into assets.
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Bundle protocol allows for easly making a protocol that takes
        // bytes and returns bundle with optional dependencies.
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        // Asset fetch tells how to get bytes from specific source.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<h2 id="goal"><a class="header" href="#goal">Goal</a></h2>
<p><code>Keket</code> started as an experiment to tell how asset management would look like
with ECS as its storage, how we could make it play with modularity, what benefits
does ECS storage gives us.</p>
<p>Soon after first version got done, i've realized that it is quite powerful and
easily extendable, when we treat assets as entities with components as their data
(and meta data) and asset loaders (and systems outside of asset management) can
process and change assets in bulk the way they need, while not forcing any
particular closed specs structure on the assets themselves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-database"><a class="header" href="#asset-database">Asset Database</a></h1>
<p>Let's dive into central point of the library - asset database.</p>
<p><code>AssetDatabase</code> is a thin, higher level abstraction for underlying (public) ECS
storage where assets data live.</p>
<p>ECS as storage allowed to treat assets as rows in database tables, where single
asset can have multiple data columns associated with given asset. This opened up
a possibility for fast queries and lookups on multiple entities that pass given
requirements (set of components).</p>
<p>This is very important for systems which process and modify assets in specific
for them ways (in <code>Keket</code> those systems are asset fetch engines and asset
protocols - more about them later in the book).</p>
<p>We can use queries and lookups to process only assets that have given set of
requirements based on the data they store. For example when we load assets with
<code>FileAssetFetch</code>, we get not only asset data, but also meta data as <code>PathBuf</code> and
<code>Metadata</code> components, so if we want to for example scan database for all assets
that come from file system, we can just query them with <code>PathBuf</code> component and
use that fast query for asset statistics report.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Asset protocols tell how to deserialize bytes into assets.
</span><span class="boring">        .with_protocol(TextAssetProtocol)
</span><span class="boring">        .with_protocol(BytesAssetProtocol)
</span><span class="boring">        // Bundle protocol allows for easly making a protocol that takes
</span><span class="boring">        // bytes and returns bundle with optional dependencies.
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
</span><span class="boring">            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
</span><span class="boring">            Ok((asset,).into())
</span><span class="boring">        }))
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
</span><span class="boring">            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
</span><span class="boring">            Ok((asset,).into())
</span><span class="boring">        }))
</span><span class="boring">        // Asset fetch tells how to get bytes from specific source.
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span><span class="boring">    // Ensure method either gives existing asset handle or creates new
</span><span class="boring">    // and loads asset if not existing yet in storage.
</span><span class="boring">    let lorem = database.ensure("text://lorem.txt")?;
</span><span class="boring">    // Accessing component(s) of asset entry.
</span><span class="boring">    // Assets can store multiple data associated to them, consider them meta data.
</span><span class="boring">    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    let json = database.ensure("json://person.json")?;
</span><span class="boring">    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    let person = database.ensure("person://person.json")?;
</span><span class="boring">    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    let trash = database.ensure("bytes://trash.bin")?;
</span><span class="boring">    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));
</span><span class="boring">
</span>    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>Since storage is just an ECS, every asset entity always must store at least
<code>AssetPath</code> component to be considered valid asset - every component other than
asset path is considered asset data that is either usable for outside systems,
or for asset fetch engines and asset protocols as meta data for them in asset
resolution process.</p>
<blockquote>
<p>When an asset entity stores some components without asset path, then it is
never considered an actual asset, and rather an entity not important to asset
management - some systems might find it useful for them, but it is highly not
advised to put there anything other than assets.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-life-cycle"><a class="header" href="#asset-life-cycle">Asset life cycle</a></h1>
<p>There is standarized progression in asset life cycle:</p>
<ul>
<li><strong>Awaits for resolution</strong> - database triggers fetching bytes for these.</li>
<li><strong>Bytes are ready to be processed</strong> - database takes those loaded bytes from asset
and runs asset protocol (by asset path protocol part) on these bytes.</li>
<li><strong>Asset is ready to use</strong> - bytes are decoded into asset components and put in
given asset for use by outside systems.</li>
<li><strong>Asset is unloaded</strong> - asset entity gets despawned and when ensured again it will
be marked as awaiting resolution.</li>
</ul>
<blockquote>
<p>It might be the case where sometimes one or more of these steps are missed, for
example when asset is added manually (user has all asset components made and
spawns asset directly into storage, without fetching bytes, etc) - in that case
given asset never goes through asset fetch engines and asset protocols (yet is
still discoverable by change detection).</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-handle"><a class="header" href="#asset-handle">Asset Handle</a></h1>
<p><code>AssetHandle</code> is a thin wrapper around ECS entity type (generational index).
Its used as key to asset in database, to allow said database to perform operations
on the asset using that handle - handles are returned when asset gets spawned in
storage, so every spawned handle always point to existing asset (unless asset gets
unloaded/deleted).</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Asset protocols tell how to deserialize bytes into assets.
</span><span class="boring">        .with_protocol(TextAssetProtocol)
</span><span class="boring">        .with_protocol(BytesAssetProtocol)
</span><span class="boring">        // Bundle protocol allows for easly making a protocol that takes
</span><span class="boring">        // bytes and returns bundle with optional dependencies.
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
</span><span class="boring">            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
</span><span class="boring">            Ok((asset,).into())
</span><span class="boring">        }))
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
</span><span class="boring">            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
</span><span class="boring">            Ok((asset,).into())
</span><span class="boring">        }))
</span><span class="boring">        // Asset fetch tells how to get bytes from specific source.
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span>    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));
<span class="boring">
</span><span class="boring">    // We can query storage for asset components to process assets, just like with ECS.
</span><span class="boring">    for (asset_path, file_path, metadata) in database
</span><span class="boring">        .storage
</span><span class="boring">        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
</span><span class="boring">    {
</span><span class="boring">        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-path"><a class="header" href="#asset-path">Asset Path</a></h1>
<p><code>AssetPath</code> serves as thin wrapper around copy-on-write string with cached ranges
of standarized path (<code>&lt;protocol&gt;://&lt;path&gt;?&lt;key1&gt;=&lt;value1&gt;&amp;&lt;flag&gt;</code>) components:</p>
<ul>
<li>protocol</li>
<li>path</li>
<li>optional meta data</li>
</ul>
<p>Example asset paths:</p>
<ul>
<li><code>ui/texts/lorem.txt</code> - asset path without protocol, only path part.</li>
<li><code>text://ui/texts/lorem.txt</code> - asset path with protocol.</li>
<li><code>text://ui/texts/lorem.txt?v=3&amp;uppercase</code> - asset path with path and meta key-values.</li>
</ul>
<p>Most common asset paths are ones with protocol and meta key-values. Paths without
protocols are possible, but not useful, unless you register an asset protocol
that handles them (which is almost never the case, but one could have it as
protocol resolved by any other means - since library is modular, user can setup
database however they like).</p>
<p>Asset paths are useful mostly in getting asset handles by their asset paths, or
storage queries/lookups by specific asset path.</p>
<pre><code class="language-rust ignore">let path = AssetPath::new("text://lorem.txt?v=3&amp;uppercase");

println!("- protocol: {:?}", path.protocol());
for segment in path.path_parts() {
    println!("  - path segment: {:?}", segment);
}
for (key, value) in path.meta_items() {
    println!("  - path meta key: {:?} value: {:?}", key, value);
}

let lorem = database.ensure(path)?;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-reference"><a class="header" href="#asset-reference">Asset Reference</a></h1>
<p><code>AssetRef</code> is a thin wrapper around asset path and optional cached asset handle.</p>
<p>The goal here was to allow to reduce resolving asset handles to one resolution
for given asset reference - searching for asset handle by asset path is unnecessary
work to do everytime we point to an asset by path and need to perform operations
on its handle, so with asset reference we can resolve asset handle once and reuse
its cached handle for future database operations.</p>
<p>Additional justification for asset references is serialization - this is preferred
way to reference assets in serializable data, so once container gets deserializaed
into typed data, asset handle resolution will happen only at first time.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, reference::AssetRef},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::bundle::{
</span><span class="boring">        BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("custom", CustomAssetProcessor))
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span><span class="boring">    let handle = database.ensure("custom://part1.json")?;
</span><span class="boring">
</span><span class="boring">    while database.is_busy() {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
</span><span class="boring">    println!("Custom chain contents: {contents:?}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Debug, Default, Deserialize)]
struct CustomAsset {
    content: String,
    // Asset references are used to store path and cached handle. They serialize as asset paths.
    // They can be used where we need to have an ability to reference asset by path, and ask
    // for handle once instead of everytime as with asset paths.
    #[serde(default)]
    next: Option&lt;AssetRef&gt;,
}

impl CustomAsset {
    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
        let mut result = self.content.as_str().to_owned();
        if let Some(next) = self.next.as_ref() {
            result.push(' ');
            if let Ok(resolved) = next.resolve(database) {
                result.push_str(&amp;resolved.access::&lt;&amp;Self&gt;().contents(database));
            }
        }
        result
    }
}
<span class="boring">
</span><span class="boring">struct CustomAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for CustomAssetProcessor {
</span><span class="boring">    type Bundle = (CustomAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;
</span><span class="boring">        let dependency = asset
</span><span class="boring">            .next
</span><span class="boring">            .as_ref()
</span><span class="boring">            .map(|reference| reference.path().clone());
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,)).maybe_dependency(dependency))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, reference::AssetRef},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::bundle::{
</span><span class="boring">        BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(BundleAssetProtocol::new("custom", CustomAssetProcessor))
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    let handle = database.ensure("custom://part1.json")?;

    while database.is_busy() {
        database.maintain()?;
    }

    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
    println!("Custom chain contents: {contents:?}");
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Default, Deserialize)]
</span><span class="boring">struct CustomAsset {
</span><span class="boring">    content: String,
</span><span class="boring">    // Asset references are used to store path and cached handle. They serialize as asset paths.
</span><span class="boring">    // They can be used where we need to have an ability to reference asset by path, and ask
</span><span class="boring">    // for handle once instead of everytime as with asset paths.
</span><span class="boring">    #[serde(default)]
</span><span class="boring">    next: Option&lt;AssetRef&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomAsset {
</span><span class="boring">    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
</span><span class="boring">        let mut result = self.content.as_str().to_owned();
</span><span class="boring">        if let Some(next) = self.next.as_ref() {
</span><span class="boring">            result.push(' ');
</span><span class="boring">            if let Ok(resolved) = next.resolve(database) {
</span><span class="boring">                result.push_str(&amp;resolved.access::&lt;&amp;Self&gt;().contents(database));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CustomAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for CustomAssetProcessor {
</span><span class="boring">    type Bundle = (CustomAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;
</span><span class="boring">        let dependency = asset
</span><span class="boring">            .next
</span><span class="boring">            .as_ref()
</span><span class="boring">            .map(|reference| reference.path().clone());
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,)).maybe_dependency(dependency))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><code>SmartAssetRef</code> is a thin wrapper arount asset reference, that uses database
asset reference counting feature to automatically handle asset lifetime and
despawn asset when counter drops to 0.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, AssetReferenceCounter, reference::SmartAssetRef},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::text::TextAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Load asset and mark its first reference.
    let first = SmartAssetRef::new("text://lorem.txt", &amp;mut database)?;
    println!(
        "Lorem Ipsum: {}",
        first.resolve(&amp;database)?.access::&lt;&amp;String&gt;()
    );
    database.maintain()?;
    assert_eq!(database.storage.len(), 1);
    assert_eq!(
        first
            .resolve(&amp;database)?
            .access::&lt;&amp;AssetReferenceCounter&gt;()
            .counter(),
        1
    );

    // Clone the asset and mark its second reference.
    let second = first.clone();
    database.maintain()?;
    assert_eq!(database.storage.len(), 1);
    assert_eq!(
        second
            .resolve(&amp;database)?
            .access::&lt;&amp;AssetReferenceCounter&gt;()
            .counter(),
        2
    );

    // Ensure asset again from scratch and mark its third reference.
    let third = SmartAssetRef::new("text://lorem.txt", &amp;mut database)?;
    database.maintain()?;
    assert_eq!(database.storage.len(), 1);
    assert_eq!(
        third
            .resolve(&amp;database)?
            .access::&lt;&amp;AssetReferenceCounter&gt;()
            .counter(),
        3
    );

    // Drop the first reference and expect 2 references.
    drop(first);
    database.maintain()?;
    assert_eq!(database.storage.len(), 1);
    assert_eq!(
        third
            .resolve(&amp;database)?
            .access::&lt;&amp;AssetReferenceCounter&gt;()
            .counter(),
        2
    );

    // Drop the second reference and expect 1 reference.
    drop(second);
    database.maintain()?;
    assert_eq!(database.storage.len(), 1);
    assert_eq!(
        third
            .resolve(&amp;database)?
            .access::&lt;&amp;AssetReferenceCounter&gt;()
            .counter(),
        1
    );

    // Drop the third reference and expect no references and asset no more existing.
    drop(third);
    database.maintain()?;
    assert_eq!(database.storage.len(), 0);
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-events"><a class="header" href="#asset-events">Asset Events</a></h1>
<p><code>AssetEventBindings</code> is a container for event listeners that will be notified
about particular asset (or all assets) progression.</p>
<p>User can put asset event bindings into particular asset, then some code can bind
its listener (anything that implements <code>AssetEventListener</code> trait, for example
closure or <code>Sender</code>), and once asset progression changes, that will be dispatched
to registered listeners. User can also listen for all asset events by registering
to event bindings in asset database.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, events::AssetEventBindings},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, sync::mpsc::channel};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        .with_protocol(TextAssetProtocol)
</span><span class="boring">        .with_protocol(BytesAssetProtocol)
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
</span><span class="boring">            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
</span><span class="boring">            Ok((asset,).into())
</span><span class="boring">        }))
</span><span class="boring">        .with_protocol(GroupAssetProtocol)
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span>    // We can bind closures to asset event bindings for any asset progression tracking.
    database.events.bind(|event| {
        println!("Asset closure event: {event:#?}");
        Ok(())
    });

    // Create channel for asset events communication.
    let (tx, rx) = channel();

    // Start loading asset and its dependencies.
    let group = database.ensure("group://group.txt")?;
    // We can also bind sender to asset event bindings.
    group.ensure::&lt;AssetEventBindings&gt;(&amp;mut database)?.bind(tx);

    while database.is_busy() {
        database.maintain()?;
    }

    // Read sent events from receiver.
    while let Ok(event) = rx.try_recv() {
        println!("Group channel event: {event:#?}");
    }
<span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "Lorem Ipsum: {}",
</span><span class="boring">        database
</span><span class="boring">            .find("text://lorem.txt")
</span><span class="boring">            .unwrap()
</span><span class="boring">            .access::&lt;&amp;String&gt;(&amp;database)
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-fetch"><a class="header" href="#asset-fetch">Asset Fetch</a></h1>
<p>Asset fetch engines are units that implement <code>AssetFetch</code> trait that tells asset
manager how and where from to get requested asset bytes. This covers first step
of asset progression, where next step uses asset protocol to decode loaded bytes.</p>
<p>Usually what we can see in asset management libraries is asset loaders, which are
combination of loading bytes (from some specific to them source) and decoding
bytes into asset object. I've found this approach unnecessarily fixed and forcing
requirement for either implementing same asset loader for every asset source, or
to make all possible asset sources implemented in asset loader.</p>
<p>In <code>Keket</code> i went with decoupling bytes loading from bytes decoding, so that user
can for example use different bytes source for different build mode or different
platform, without having to bytes decoding to care about where bytes come from.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Asset protocols tell how to deserialize bytes into assets.
</span><span class="boring">        .with_protocol(TextAssetProtocol)
</span><span class="boring">        .with_protocol(BytesAssetProtocol)
</span><span class="boring">        // Bundle protocol allows for easly making a protocol that takes
</span><span class="boring">        // bytes and returns bundle with optional dependencies.
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
</span><span class="boring">            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
</span><span class="boring">            Ok((asset,).into())
</span><span class="boring">        }))
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
</span><span class="boring">            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
</span><span class="boring">            Ok((asset,).into())
</span><span class="boring">        }))
</span><span class="boring">        // Asset fetch tells how to get bytes from specific source.
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span><span class="boring">    // Ensure method either gives existing asset handle or creates new
</span><span class="boring">    // and loads asset if not existing yet in storage.
</span><span class="boring">    let lorem = database.ensure("text://lorem.txt")?;
</span><span class="boring">    // Accessing component(s) of asset entry.
</span><span class="boring">    // Assets can store multiple data associated to them, consider them meta data.
</span><span class="boring">    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    let json = database.ensure("json://person.json")?;
</span><span class="boring">    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    let person = database.ensure("person://person.json")?;
</span><span class="boring">    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    let trash = database.ensure("bytes://trash.bin")?;
</span><span class="boring">    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    // We can query storage for asset components to process assets, just like with ECS.
</span><span class="boring">    for (asset_path, file_path, metadata) in database
</span><span class="boring">        .storage
</span><span class="boring">        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
</span><span class="boring">    {
</span><span class="boring">        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span>let mut database = AssetDatabase::default()
    .with_protocol(TextAssetProtocol)
    // Whichever asset source we use, we will make them async load.
    .with_fetch(DeferredAssetFetch::new(
        // Hot-reloading assets from file system for development.
        #[cfg(not(feature = "shipping"))]
        HotReloadFileAssetFetch::new(
            FileAssetFetch::default().with_root("assets"),
            Duration::from_secs(5),
        )?
        // Loading assets from asset pack REDB database.
        #[cfg(feature = "shipping")]
        ContainerAssetFetch::new(RedbContainerPartialFetch::new(
            Database::create("./assets.redb")?,
            "assets",
        ))
    ));

let handle = database.ensure("text://lorem.txt")?;
println!("Lorem Ipsum: {}", handle.access::&lt;&amp;String&gt;(&amp;database));</code></pre>
<p>And this is how easy it is to implement new asset fetch engine:</p>
<pre><code class="language-rust ignore">impl AssetFetch for FileAssetFetch {
    fn load_bytes(&amp;self, path: AssetPath) -&gt; Result&lt;DynamicBundle, Box&lt;dyn Error&gt;&gt; {
        let file_path = self.root.join(path.path());
        let bytes = std::fs::read(&amp;file_path)
            .map_err(|error| format!("Failed to load `{:?}` file bytes: {}", file_path, error))?;
        let mut bundle = DynamicBundle::default();
        bundle
            .add_component(AssetBytesAreReadyToProcess(bytes))
            .ok()
            .unwrap();
        bundle.add_component(AssetFromFile).ok().unwrap();
        bundle
            .add_component(std::fs::metadata(&amp;file_path)?)
            .ok()
            .unwrap();
        bundle.add_component(file_path).ok().unwrap();
        Ok(bundle)
    }
}</code></pre>
<blockquote>
<p><code>AssetBytesAreReadyToProcess</code> component is crucial in asset progression, because
it marks asset for database (and outside systems) as loaded but not yet decoded,
so database can detect these assets and trigger asset decoding with their protocol.</p>
</blockquote>
<p>File asset fetch also adds other components such as:</p>
<ul>
<li><code>AssetFromFile</code> - tag component that allows to query all assets from file system.</li>
<li><code>std::fs::Metadata</code> - file metadata that can be used for example for size stats.</li>
<li><code>PathBuf</code> - file system path that can be used for stuff like hot reloading.</li>
</ul>
<p>Asset fetch engines other than <code>FileAssetFetch</code> also do add their own custom
metadata to asset.</p>
<p>It's worth also to know that asset database uses stack of asset fetch engines,
to allow changing source of assets for particular code paths - we can push, pop,
swap or use-in-place fetch engines. Typical scenario of that would be to
procedurally create an asset container that we can then use as container source
for future assets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-system"><a class="header" href="#file-system">File system</a></h1>
<p><code>FileAssetFetch</code> is a simple fetch engine that reads entire bytes of an asset
file synchronously.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        // Asset protocols tell how to deserialize bytes into assets.
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Bundle protocol allows for easly making a protocol that takes
        // bytes and returns bundle with optional dependencies.
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        // Asset fetch tells how to get bytes from specific source.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>Since this is blocking fetch, you might want to wrap it with <code>DeferredAssetFetch</code>
to run file system fetching jobs in background.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="in-memory-collections"><a class="header" href="#in-memory-collections">In-memory collections</a></h1>
<p>In rare cases we need to have assets in-memory - embeded platforms, or just assets
baked into binary (typically simple web wasm games) - we can use collections to
store paths and their bytes and allow assets to be fetched from there.</p>
<pre><code class="language-rust ignore">const ASSETS: &amp;[(&amp;str, &amp;[u8])] = &amp;[
    ("lorem.txt", include_bytes!("./assets/lorem.txt")),
    ("trash.bin", include_bytes!("./assets/trash.bin")),
];

let mut database = AssetDatabase::default()
    .with_protocol(TextAssetProtocol)
    .with_protocol(BytesAssetProtocol)
    .with_fetch(ASSETS);

let lorem = database.ensure("text://lorem.txt")?;
println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

let trash = database.ensure("bytes://trash.bin")?;
println!("Trash: {:?}", bytes.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hot-reloading-wrapper-for-file-system"><a class="header" href="#hot-reloading-wrapper-for-file-system">Hot-reloading wrapper for file system</a></h1>
<p><code>HotReloadAssetFetch</code> wrapper alows assets loaded from <code>FileAssetFetch</code> to be
watched and reloaded when source file changes.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetHandle, path::AssetPath},
</span><span class="boring">    fetch::{file::FileAssetFetch, hotreload::HotReloadFileAssetFetch},
</span><span class="boring">    protocol::{bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use std::{error::Error, time::Duration};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Hot reload wrapper watches for changes in file fetch root path.
        .with_fetch(HotReloadFileAssetFetch::new(
            FileAssetFetch::default().with_root("resources"),
            // File system watcher polling interval.
            Duration::from_secs(5),
        )?);

    // First we fill database with some assets, hot reload only
    // cares about changes in files present in database.
    database.ensure("text://lorem.txt")?;
    database.ensure("bytes://trash.bin")?;

    println!("Watching for file changes...");
    loop {
        database.maintain()?;

        // With storage change detection we can ask for asset entities
        // that their paths were updated (hot reloading updates them).
        if let Some(changes) = database.storage.updated() {
            for entity in changes.iter_of::&lt;AssetPath&gt;() {
                println!(
                    "Asset changed: `{}`",
                    AssetHandle::new(entity).access::&lt;&amp;AssetPath&gt;(&amp;database)
                );
            }
        }

        // Simulate systems that detect particular asset type reload.
        for entity in database.storage.added().iter_of::&lt;String&gt;() {
            println!(
                "Text asset changed: `{}`",
                AssetHandle::new(entity).access::&lt;&amp;String&gt;(&amp;database)
            );
        }
        for entity in database.storage.added().iter_of::&lt;Vec&lt;u8&gt;&gt;() {
            println!(
                "Bytes asset changed: `{:?}`",
                AssetHandle::new(entity).access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database)
            );
        }
    }
<span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deferred-loading-wrapper"><a class="header" href="#deferred-loading-wrapper">Deferred loading wrapper</a></h1>
<p><code>DeferredAssetFetch</code> allows to asynchronously load requested bytes in background
thread(s). It is encouraged to use it for heavy latency fetch engines like file
system or network fetch engines.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::AssetDatabase,
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::bytes::BytesAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(BytesAssetProtocol)
        // Deferred asset fetch runs fetching jobs in threads for any fetch engine.
        .with_fetch(DeferredAssetFetch::new(
            FileAssetFetch::default().with_root("resources"),
        ));

    let package = database.ensure("bytes://package.zip")?;

    // Simulate waiting for asset bytes loading to complete.
    while package.awaits_async_fetch(&amp;database) {
        println!("Package awaits async fetch done");
        database.maintain()?;
    }

    // Run another maintain pass to process loaded bytes.
    database.maintain()?;

    println!(
        "Package byte size: {}",
        package.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database).len()
    );
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-loading-wrapper"><a class="header" href="#async-loading-wrapper">Async loading wrapper</a></h1>
<p><code>FutureAssetFetch</code> allows to asynchronously load requested bytes in async/await
futures. It's similar to <code>DeferredAssetFetch</code>, although it expects provided
custom async function that will handle loading asset bytes with custom
async/await compatible libraries like <code>tokio</code>.</p>
<pre><code class="language-rust ignore"><span class="boring">use anput::bundle::DynamicBundle;
</span><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPathStatic},
</span><span class="boring">    fetch::{AssetBytesAreReadyToProcess, future::FutureAssetFetch},
</span><span class="boring">    protocol::bytes::BytesAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::{error::Error, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(BytesAssetProtocol)
        // Future asset fetch uses async function to handle providing
        // asset bytes asynchronously with async/await.
        .with_fetch(FutureAssetFetch::new(tokio_load_file_bundle));

    let package = database.ensure("bytes://package.zip")?;

    // Run maintain passes to load and process loaded bytes.
    while !package.is_ready_to_use(&amp;database) {
        database.maintain()?;
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
    }

    println!(
        "Package byte size: {}",
        package.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database).len()
    );
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">async fn tokio_load_file_bundle(path: AssetPathStatic) -&gt; Result&lt;DynamicBundle, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let file_path = PathBuf::from("resources").join(path.path());
</span><span class="boring">
</span><span class="boring">    let bytes = tokio::fs::read(&amp;file_path).await?;
</span><span class="boring">
</span><span class="boring">    let mut bundle = DynamicBundle::default();
</span><span class="boring">    bundle
</span><span class="boring">        .add_component(AssetBytesAreReadyToProcess(bytes))
</span><span class="boring">        .map_err(|_| format!("Failed to add bytes to bundle for asset: {path}"))?;
</span><span class="boring">    Ok(bundle)
</span><span class="boring">}</span></code></pre>
<p>And here is async function that handles loading bytes with <code>tokio</code>:</p>
<pre><code class="language-rust ignore"><span class="boring">use anput::bundle::DynamicBundle;
</span><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPathStatic},
</span><span class="boring">    fetch::{AssetBytesAreReadyToProcess, future::FutureAssetFetch},
</span><span class="boring">    protocol::bytes::BytesAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::{error::Error, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        .with_protocol(BytesAssetProtocol)
</span><span class="boring">        // Future asset fetch uses async function to handle providing
</span><span class="boring">        // asset bytes asynchronously with async/await.
</span><span class="boring">        .with_fetch(FutureAssetFetch::new(tokio_load_file_bundle));
</span><span class="boring">
</span><span class="boring">    let package = database.ensure("bytes://package.zip")?;
</span><span class="boring">
</span><span class="boring">    // Run maintain passes to load and process loaded bytes.
</span><span class="boring">    while !package.is_ready_to_use(&amp;database) {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        "Package byte size: {}",
</span><span class="boring">        package.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database).len()
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>async fn tokio_load_file_bundle(path: AssetPathStatic) -&gt; Result&lt;DynamicBundle, Box&lt;dyn Error&gt;&gt; {
    let file_path = PathBuf::from("resources").join(path.path());

    let bytes = tokio::fs::read(&amp;file_path).await?;

    let mut bundle = DynamicBundle::default();
    bundle
        .add_component(AssetBytesAreReadyToProcess(bytes))
        .map_err(|_| format!("Failed to add bytes to bundle for asset: {path}"))?;
    Ok(bundle)
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assets-container-wrapper"><a class="header" href="#assets-container-wrapper">Assets container wrapper</a></h1>
<p><code>ContainerAssetFetch</code> allows for partial loading from sources that are considered
containers that store other assets. Typical container example would be ZIP archives,
databases, etc.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::container::{ContainerAssetFetch, ContainerPartialFetch},
</span><span class="boring">    protocol::text::TextAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::{error::Error, fs::File, io::Read};
</span><span class="boring">use zip::ZipArchive;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        .with_protocol(TextAssetProtocol)
</span><span class="boring">        // Container asset fetch allows to use partial asset fetch object
</span><span class="boring">        // that can take asset path and returns bytes from some container.
</span><span class="boring">        .with_fetch(ContainerAssetFetch::new(ZipContainerPartialFetch::new(
</span><span class="boring">            ZipArchive::new(File::open("./resources/package.zip")?)?,
</span><span class="boring">        )));
</span><span class="boring">
</span><span class="boring">    let lorem = database.ensure("text://lorem.txt")?;
</span><span class="boring">    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>// Here we show how to make ZIP archive file reader.
struct ZipContainerPartialFetch {
    archive: ZipArchive&lt;File&gt;,
}

impl ZipContainerPartialFetch {
    pub fn new(archive: ZipArchive&lt;File&gt;) -&gt; Self {
        Self { archive }
    }
}

impl ContainerPartialFetch for ZipContainerPartialFetch {
    // We use input path and try to unpack file under that path from ZIP archive.
    fn load_bytes(&amp;mut self, path: AssetPath) -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn Error&gt;&gt; {
        let mut file = self
            .archive
            .by_name(path.path())
            .map_err(|error| format!("Could not read zip file: `{}` - {}", path.path(), error))?;
        let mut bytes = vec![];
        file.read_to_end(&amp;mut bytes)?;
        Ok(bytes)
    }
}</code></pre>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::container::{ContainerAssetFetch, ContainerPartialFetch},
</span><span class="boring">    protocol::text::TextAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::{error::Error, fs::File, io::Read};
</span><span class="boring">use zip::ZipArchive;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        // Container asset fetch allows to use partial asset fetch object
        // that can take asset path and returns bytes from some container.
        .with_fetch(ContainerAssetFetch::new(ZipContainerPartialFetch::new(
            ZipArchive::new(File::open("./resources/package.zip")?)?,
        )));

    let lorem = database.ensure("text://lorem.txt")?;
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Here we show how to make ZIP archive file reader.
</span><span class="boring">struct ZipContainerPartialFetch {
</span><span class="boring">    archive: ZipArchive&lt;File&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ZipContainerPartialFetch {
</span><span class="boring">    pub fn new(archive: ZipArchive&lt;File&gt;) -&gt; Self {
</span><span class="boring">        Self { archive }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ContainerPartialFetch for ZipContainerPartialFetch {
</span><span class="boring">    // We use input path and try to unpack file under that path from ZIP archive.
</span><span class="boring">    fn load_bytes(&amp;mut self, path: AssetPath) -&gt; Result&lt;Vec&lt;u8&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut file = self
</span><span class="boring">            .archive
</span><span class="boring">            .by_name(path.path())
</span><span class="boring">            .map_err(|error| format!("Could not read zip file: `{}` - {}", path.path(), error))?;
</span><span class="boring">        let mut bytes = vec![];
</span><span class="boring">        file.read_to_end(&amp;mut bytes)?;
</span><span class="boring">        Ok(bytes)
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fallback-assets-wrapper"><a class="header" href="#fallback-assets-wrapper">Fallback assets wrapper</a></h1>
<p><code>FallbackAssetFetch</code> allows to provide list of assets that should be considered
to load instead of requested assets (with matching protocol) when requested asset
fails to load - for example if requested texture does not exists, we can fallback
to popular magenta solid color texture that indicates missing textures.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::AssetDatabase,
</span><span class="boring">    fetch::{fallback::FallbackAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::text::TextAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_fetch(
            // Fallback asset fetch in case of error on requested asset bytes load
            // will try to load asset with matching protocol from fallback paths.
            FallbackAssetFetch::new(FileAssetFetch::default().with_root("resources"))
                // This fallback asset does not exists so it will be ignored.
                .path("text://this-fails-to-load.txt")
                // This asset exists so it will be loaded as fallback.
                .path("text://lorem.txt"),
        );

    // This asset exists so it loads normally.
    let lorem = database.ensure("text://lorem.txt")?;

    // This asset does not exists so it loads fallback asset.
    let non_existent = database.ensure("text://non-existent.txt")?;

    if lorem.access::&lt;&amp;String&gt;(&amp;database) == non_existent.access::&lt;&amp;String&gt;(&amp;database) {
        println!("Non existent asset loaded from fallback!");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="router-fetch-wrapper"><a class="header" href="#router-fetch-wrapper">Router fetch wrapper</a></h1>
<p><code>RouterAssetFetch</code> allows to combine multiple fetch engines into routes, so that
specific fetch engine to use for given asset is decided by the pattern in asset
path - this is useful when we might want to have main game assets and additional
DLC/mod asset sources.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::AssetDatabase,
</span><span class="boring">    fetch::{file::FileAssetFetch, router::RouterAssetFetch},
</span><span class="boring">    protocol::{bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        .with_fetch(
            // Router allows to combine multiple asset sources, so that proper one to use
            // for given asset is selected by pattern in asset path.
            RouterAssetFetch::default()
                // Every asset that has `router=file` meta, will load asset from file.
                .route(
                    |path| path.has_meta_key_value("router", "file"),
                    FileAssetFetch::default().with_root("resources"),
                    0,
                )
                // Every asset that has `memory/` path prefix, will load from in-memory collection.
                .route(
                    |path| path.path().starts_with("memory/"),
                    vec![(
                        "memory/trash.bin".to_owned(),
                        std::fs::read("./resources/trash.bin")?,
                    )],
                    1,
                ),
        );

    // This asset will select file router.
    let lorem = database.ensure("text://lorem.txt?router=file")?;
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    // This asset will select memory router.
    let trash = database.ensure("bytes://memory/trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rewrite-asset-path-wrapper"><a class="header" href="#rewrite-asset-path-wrapper">Rewrite asset path wrapper</a></h1>
<p><code>RewriteAssetFetch</code> allows to rewrite requested asset path to some other.
This is useful for scenarios like localized assets or assets versioning, where
there might be different versions of assets based on some runtime state.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::{file::FileAssetFetch, rewrite::RewriteAssetFetch},
</span><span class="boring">    protocol::text::TextAssetProtocol,
</span><span class="boring">};
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let language = Arc::new(RwLock::new("en"));
    let language2 = language.clone();

    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_fetch(RewriteAssetFetch::new(
            FileAssetFetch::default().with_root("resources"),
            move |path| {
                // Rewrite input path to localized one.
                Ok(AssetPath::from_parts(
                    path.protocol(),
                    &amp;format!(
                        "{}.{}{}",
                        path.path_without_extension(),
                        *language2.read().unwrap(),
                        path.path_dot_extension().unwrap_or_default()
                    ),
                    path.meta(),
                ))
            },
        ));

    // Gets `text://localized.en.txt`.
    let asset = database.ensure("text://localized.txt")?;
    println!("English: {}", asset.access::&lt;&amp;String&gt;(&amp;database));

    // Change language.
    *language.write().unwrap() = "de";
    database.storage.clear();

    // Gets `text://localized.de.txt`.
    let asset = database.ensure("text://localized.txt")?;
    println!("German: {}", asset.access::&lt;&amp;String&gt;(&amp;database));
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>Rewritten asset paths do not change path in asset entity - this is deliberate
design decision to make outside systems not care about possible asset path
change when trying to resolve asset handle by its path.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extract-from-asset"><a class="header" href="#extract-from-asset">Extract from asset</a></h1>
<p><code>ExtractAssetFetch</code> allows for extracting asset bytes from storage. You can
specialize extraction with specific asset as source.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::AssetDatabase,
</span><span class="boring">    fetch::{
</span><span class="boring">        extract::{ExtractAssetFetch, from_asset_extractor},
</span><span class="boring">        file::FileAssetFetch,
</span><span class="boring">    },
</span><span class="boring">    protocol::{bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use std::{error::Error, io::Cursor, io::Read};
</span><span class="boring">use zip::ZipArchive;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // We start with regular fetch engine.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Start loading package ZIP bytes.
    database.ensure("bytes://package.zip")?;

    // Maintain database while busy.
    while database.is_busy() {
        database.maintain()?;
    }

    // Then we push extraction asset fetch to fetch engine stack. From now on
    // any future asset request will be extracted from loaded ZIP archive.
    database.push_fetch(ExtractAssetFetch::new(from_asset_extractor(
        "bytes://package.zip",
        |bytes: &amp;Vec&lt;u8&gt;, path| {
            let mut archive = ZipArchive::new(Cursor::new(bytes))?;
            let mut file = archive.by_name(path.path())?;
            let mut result = vec![];
            file.read_to_end(&amp;mut result)?;
            Ok(result)
        },
    )));

    // Extract some assets from ZIP asset.
    let lorem = database.ensure("text://lorem.txt")?;
    let trash = database.ensure("bytes://trash.bin")?;

    // Run maintenance to process extracted asset bytes.
    database.maintain()?;

    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http-requests"><a class="header" href="#http-requests">HTTP requests</a></h1>
<blockquote>
<p><strong>Required crate: <code>keket-http</code>.</strong></p>
</blockquote>
<p><code>HttpAssetFetch</code> allows to fetch bytes with HTTP sources.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::deferred::DeferredAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use keket_http::{HttpAssetFetch, third_party::reqwest::Url};
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            Ok((serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?,).into())
        }))
        // HTTP asset fetch with root URL for assets.
        .with_fetch(DeferredAssetFetch::new(HttpAssetFetch::new(
            "https://raw.githubusercontent.com/PsichiX/Keket/refs/heads/master/resources/",
        )?));

    // Ensure assets exists or start getting fetched.
    let lorem = database.ensure("text://lorem.txt")?;
    let json = database.ensure("json://person.json")?;
    let trash = database.ensure("bytes://trash.bin")?;

    // Wait while database is busy.
    while database.is_busy() {
        println!("Waiting for database to be free");
        println!(
            "Loading:\n- Lorem Ipsum: {}\n- JSON: {}\n- Bytes: {}",
            lorem.awaits_async_fetch(&amp;database),
            json.awaits_async_fetch(&amp;database),
            trash.awaits_async_fetch(&amp;database)
        );
        database.maintain()?;
    }

    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // List all assets from HTTP.
    for (asset_path, url) in database.storage.query::&lt;true, (&amp;AssetPath, &amp;Url)&gt;() {
        println!("Asset: `{asset_path}` at url: `{url}`");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>Since this is blocking fetch, you might want to wrap it with <code>DeferredAssetFetch</code>
to run HTTP fetching jobs in background.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="redb-database"><a class="header" href="#redb-database">REDB database</a></h1>
<blockquote>
<p><strong>Required crate: <code>keket-redb</code>.</strong></p>
</blockquote>
<p><code>RedbContainerPartialFetch</code> partial fetch engine allows to unpack asset bytes
from REDB database - useful for asset packs.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::AssetDatabase,
</span><span class="boring">    fetch::container::ContainerAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use keket_redb::{RedbContainerPartialFetch, third_party::redb::Database};
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            Ok((serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?,).into())
        }))
        .with_fetch(ContainerAssetFetch::new(RedbContainerPartialFetch::new(
            Database::create("./resources/database.redb")?,
            "assets",
        )));

    let lorem = database.ensure("text://lorem.txt")?;
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<blockquote>
<p>Since this is blocking fetch, you might want to wrap it with <code>DeferredAssetFetch</code>
to run REDB fetching jobs in background.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-server"><a class="header" href="#asset-server">Asset Server</a></h1>
<blockquote>
<p><strong>Required crate: <code>keket-client</code>.</strong></p>
</blockquote>
<p><code>ClientAssetFetch</code> allows to get bytes from <code>Keket</code> Asset Server (<code>keket-server</code>
binary crate) - a humble beginnings to DDC infrastructure for live development.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetHandle, path::AssetPath},
</span><span class="boring">    fetch::deferred::DeferredAssetFetch,
</span><span class="boring">    protocol::{bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use keket_client::{ClientAssetFetch, third_party::reqwest::Url};
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Client asset fetch to request files from asset server.
        .with_fetch(DeferredAssetFetch::new(ClientAssetFetch::new(
            // IP address of asset server we connect to.
            "127.0.0.1:8080",
        )?));

    // Ensure assets exists or start getting fetched.
    let lorem = database.ensure("text://lorem.txt")?;
    let trash = database.ensure("bytes://trash.bin")?;

    // Wait till database is busy.
    while database.is_busy() {
        println!("Waiting for database to be free");
        println!(
            "Loading:\n- Lorem Ipsum: {}\n- Bytes: {}",
            lorem.awaits_async_fetch(&amp;database),
            trash.awaits_async_fetch(&amp;database)
        );
        database.maintain()?;
    }

    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // List all assets from client.
    for (asset_path, url) in database.storage.query::&lt;true, (&amp;AssetPath, &amp;Url)&gt;() {
        println!("Asset: `{asset_path}` at url: `{url}`");
    }

    println!("Listening for file changes...");
    loop {
        database.maintain()?;

        // With storage change detection we can ask for asset entities
        // that their paths were updated (hot reloading updates them).
        if let Some(changes) = database.storage.updated() {
            for entity in changes.iter_of::&lt;AssetPath&gt;() {
                println!(
                    "Asset changed: `{}`",
                    AssetHandle::new(entity).access::&lt;&amp;AssetPath&gt;(&amp;database)
                );
            }
        }

        // Simulate systems that detect particular asset type reload.
        for entity in database.storage.added().iter_of::&lt;String&gt;() {
            println!(
                "Text asset changed: `{}`",
                AssetHandle::new(entity).access::&lt;&amp;String&gt;(&amp;database)
            );
        }
        for entity in database.storage.added().iter_of::&lt;Vec&lt;u8&gt;&gt;() {
            println!(
                "Bytes asset changed: `{:?}`",
                AssetHandle::new(entity).access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database)
            );
        }
    }
<span class="boring">}</span></code></pre>
<blockquote>
<p>Since this is blocking fetch, you might want to wrap it with <code>DeferredAssetFetch</code>
to run Asset Server fetching jobs in background.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-protocol"><a class="header" href="#asset-protocol">Asset Protocol</a></h1>
<p>Asset protocols are units that decode bytes and then does some things with decoded
data, usually put components into asset, schedule dependencies to load and relate
them with source asset, if there are any dependencies.</p>
<p>Asset protocols are second step in asset progression - they are decoupled from
asset fetch engines to make them not care about source of the asset and by that
be used no matter where assets come from, which solves the need for asset loaders
to implement with all possible asset sources, which is cumbersome to deal with.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        // Asset protocols tell how to deserialize bytes into assets.
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Bundle protocol allows for easly making a protocol that takes
        // bytes and returns bundle with optional dependencies.
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        // Asset fetch tells how to get bytes from specific source.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>For type to be considered asset protocol, it must implement <code>AssetProtocol</code> trait
that has methods for processing asset bytes:</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPathStatic},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::bundle::{
</span><span class="boring">        BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Register custom asset processor.
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("custom", CustomAssetProcessor))
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span><span class="boring">    // Ensure custom asset existence.
</span><span class="boring">    let handle = database.ensure("custom://part1.json")?;
</span><span class="boring">
</span><span class="boring">    // Make database process loaded dependencies.
</span><span class="boring">    while database.is_busy() {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
</span><span class="boring">    println!("Custom chain contents: {contents:?}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Custom asset type.
</span><span class="boring">#[derive(Debug, Default, Deserialize)]
</span><span class="boring">struct CustomAsset {
</span><span class="boring">    // Main content.
</span><span class="boring">    content: String,
</span><span class="boring">    // Optional sibling asset (content continuation).
</span><span class="boring">    #[serde(default)]
</span><span class="boring">    next: Option&lt;AssetPathStatic&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomAsset {
</span><span class="boring">    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
</span><span class="boring">        // Read this and it's siblings content to output.
</span><span class="boring">        let mut result = String::new();
</span><span class="boring">        let mut current = Some(self);
</span><span class="boring">        while let Some(asset) = current {
</span><span class="boring">            result.push_str(asset.content.as_str());
</span><span class="boring">            current = current
</span><span class="boring">                .as_ref()
</span><span class="boring">                .and_then(|asset| asset.next.as_ref())
</span><span class="boring">                .and_then(|path| path.find(database))
</span><span class="boring">                .and_then(|handle| handle.access_checked::&lt;&amp;Self&gt;(database));
</span><span class="boring">            if current.is_some() {
</span><span class="boring">                result.push(' ');
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomAssetProcessor;

impl BundleWithDependenciesProcessor for CustomAssetProcessor {
    // Bundle of asset components this asset processor produces from processed asset.
    type Bundle = (CustomAsset,);

    fn process_bytes(
        &amp;mut self,
        bytes: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;
        let dependency = asset.next.clone();
        // Return bundled components and optional dependency which will be additionally loaded.
        Ok(BundleWithDependencies::new((asset,)).maybe_dependency(dependency))
    }
}</code></pre>
<p>Optionally type can implement more specific asset processing that doesn't assume
you only care about bytes or even only processed asset:</p>
<pre><code class="language-rust ignore"><span class="boring">use anput::world::World;
</span><span class="boring">use keket::{
</span><span class="boring">    database::{
</span><span class="boring">        AssetDatabase,
</span><span class="boring">        handle::{AssetDependency, AssetHandle},
</span><span class="boring">        path::AssetPathStatic,
</span><span class="boring">    },
</span><span class="boring">    fetch::{AssetAwaitsResolution, AssetBytesAreReadyToProcess, file::FileAssetFetch},
</span><span class="boring">    protocol::AssetProtocol,
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Register custom asset protocol.
</span><span class="boring">        .with_protocol(CustomAssetProtocol)
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"))
</span><span class="boring">        .with_event(|event| {
</span><span class="boring">            println!("Asset closure event: {event:#?}");
</span><span class="boring">            Ok(())
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">    let handle = database.ensure("custom://part1.json")?;
</span><span class="boring">
</span><span class="boring">    while database.is_busy() {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
</span><span class="boring">    println!("Custom chain contents: {contents:?}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Custom asset type.
</span><span class="boring">#[derive(Debug, Default, Deserialize)]
</span><span class="boring">struct CustomAsset {
</span><span class="boring">    content: String,
</span><span class="boring">    #[serde(default)]
</span><span class="boring">    next: Option&lt;AssetPathStatic&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomAsset {
</span><span class="boring">    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
</span><span class="boring">        let mut result = String::new();
</span><span class="boring">        let mut current = Some(self);
</span><span class="boring">        while let Some(asset) = current {
</span><span class="boring">            result.push_str(asset.content.as_str());
</span><span class="boring">            current = current
</span><span class="boring">                .as_ref()
</span><span class="boring">                .and_then(|asset| asset.next.as_ref())
</span><span class="boring">                .and_then(|path| path.find(database))
</span><span class="boring">                .and_then(|handle| handle.access_checked::&lt;&amp;Self&gt;(database));
</span><span class="boring">            if current.is_some() {
</span><span class="boring">                result.push(' ');
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomAssetProtocol;

impl AssetProtocol for CustomAssetProtocol {
    fn name(&amp;self) -&gt; &amp;str {
        "custom"
    }

    fn process_asset_bytes(
        &amp;mut self,
        handle: AssetHandle,
        storage: &amp;mut World,
    ) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        // Always remember that in order for asset to be considered done with processing
        // bytes, it has to remove AssetBytesAreReadyToProcess component from that asset.
        // We are doing that by taking its bytes content first and removing it after.
        let bytes = {
            let mut bytes =
                storage.component_mut::&lt;true, AssetBytesAreReadyToProcess&gt;(handle.entity())?;
            std::mem::take(&amp;mut bytes.0)
        };
        storage.remove::&lt;(AssetBytesAreReadyToProcess,)&gt;(handle.entity())?;

        // Once we have asset bytes, we decode them into asset data.
        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;

        // We also have to extract dependencies if it has some.
        if let Some(path) = asset.next.clone() {
            // For every dependency we get, we need to spawn an asset entity with
            // AssetAwaitsResolution component to tell asset database to start loading it.
            let entity = storage.spawn((path, AssetAwaitsResolution))?;

            // We should also relate processed asset with its dependency asset.
            // Dependency relations are useful for traversing asset graphs.
            storage.relate::&lt;true, _&gt;(AssetDependency, handle.entity(), entity)?;
        }

        storage.insert(handle.entity(), (asset,))?;
        Ok(())
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bytes"><a class="header" href="#bytes">Bytes</a></h1>
<p><code>BytesAssetProtocol</code> allows to just unwrap fetched bytes into <code>Vec&lt;u8&gt;</code> component.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        // Asset protocols tell how to deserialize bytes into assets.
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Bundle protocol allows for easly making a protocol that takes
        // bytes and returns bundle with optional dependencies.
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        // Asset fetch tells how to get bytes from specific source.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="text"><a class="header" href="#text">Text</a></h1>
<p><code>TextAssetProtocol</code> allows to decode fetched bytes into <code>String</code> component.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        // Asset protocols tell how to deserialize bytes into assets.
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Bundle protocol allows for easly making a protocol that takes
        // bytes and returns bundle with optional dependencies.
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        // Asset fetch tells how to get bytes from specific source.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bundle"><a class="header" href="#bundle">Bundle</a></h1>
<p><code>BundleAssetProtocol</code> allows to create easy custom bytes decoders.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{bundle::BundleAssetProtocol, bytes::BytesAssetProtocol, text::TextAssetProtocol},
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::{error::Error, fs::Metadata, path::PathBuf};
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct Person {
</span><span class="boring">    age: u8,
</span><span class="boring">    home: PersonHome,
</span><span class="boring">    friends: Vec&lt;String&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug, Deserialize)]
</span><span class="boring">#[allow(dead_code)]
</span><span class="boring">struct PersonHome {
</span><span class="boring">    country: String,
</span><span class="boring">    address: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        // Asset protocols tell how to deserialize bytes into assets.
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        // Bundle protocol allows for easly making a protocol that takes
        // bytes and returns bundle with optional dependencies.
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        .with_protocol(BundleAssetProtocol::new("person", |bytes: Vec&lt;u8&gt;| {
            let asset = serde_json::from_slice::&lt;Person&gt;(&amp;bytes)?;
            Ok((asset,).into())
        }))
        // Asset fetch tells how to get bytes from specific source.
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    // Ensure method either gives existing asset handle or creates new
    // and loads asset if not existing yet in storage.
    let lorem = database.ensure("text://lorem.txt")?;
    // Accessing component(s) of asset entry.
    // Assets can store multiple data associated to them, consider them meta data.
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let person = database.ensure("person://person.json")?;
    println!("Person: {:#?}", person.access::&lt;&amp;Person&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    // We can query storage for asset components to process assets, just like with ECS.
    for (asset_path, file_path, metadata) in database
        .storage
        .query::&lt;true, (&amp;AssetPath, &amp;PathBuf, &amp;Metadata)&gt;()
    {
        println!("Asset: `{asset_path}` at location: {file_path:?} has metadata: {metadata:#?}");
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<p>We can use closures or any type that implements <code>BundleWithDependenciesProcessor</code>
trait, which turns input bytes into <code>BundleWithDependencies</code> container with output
components bundle and optional list of dependencies to schedule after decoding.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPathStatic},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::bundle::{
</span><span class="boring">        BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Register custom asset processor.
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("custom", CustomAssetProcessor))
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span><span class="boring">    // Ensure custom asset existence.
</span><span class="boring">    let handle = database.ensure("custom://part1.json")?;
</span><span class="boring">
</span><span class="boring">    // Make database process loaded dependencies.
</span><span class="boring">    while database.is_busy() {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
</span><span class="boring">    println!("Custom chain contents: {contents:?}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span>// Custom asset type.
#[derive(Debug, Default, Deserialize)]
struct CustomAsset {
    // Main content.
    content: String,
    // Optional sibling asset (content continuation).
    #[serde(default)]
    next: Option&lt;AssetPathStatic&gt;,
}
<span class="boring">
</span><span class="boring">impl CustomAsset {
</span><span class="boring">    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
</span><span class="boring">        // Read this and it's siblings content to output.
</span><span class="boring">        let mut result = String::new();
</span><span class="boring">        let mut current = Some(self);
</span><span class="boring">        while let Some(asset) = current {
</span><span class="boring">            result.push_str(asset.content.as_str());
</span><span class="boring">            current = current
</span><span class="boring">                .as_ref()
</span><span class="boring">                .and_then(|asset| asset.next.as_ref())
</span><span class="boring">                .and_then(|path| path.find(database))
</span><span class="boring">                .and_then(|handle| handle.access_checked::&lt;&amp;Self&gt;(database));
</span><span class="boring">            if current.is_some() {
</span><span class="boring">                result.push(' ');
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct CustomAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for CustomAssetProcessor {
</span><span class="boring">    // Bundle of asset components this asset processor produces from processed asset.
</span><span class="boring">    type Bundle = (CustomAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;
</span><span class="boring">        let dependency = asset.next.clone();
</span><span class="boring">        // Return bundled components and optional dependency which will be additionally loaded.
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,)).maybe_dependency(dependency))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPathStatic},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::bundle::{
</span><span class="boring">        BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::Deserialize;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    let mut database = AssetDatabase::default()
</span><span class="boring">        // Register custom asset processor.
</span><span class="boring">        .with_protocol(BundleAssetProtocol::new("custom", CustomAssetProcessor))
</span><span class="boring">        .with_fetch(FileAssetFetch::default().with_root("resources"));
</span><span class="boring">
</span><span class="boring">    // Ensure custom asset existence.
</span><span class="boring">    let handle = database.ensure("custom://part1.json")?;
</span><span class="boring">
</span><span class="boring">    // Make database process loaded dependencies.
</span><span class="boring">    while database.is_busy() {
</span><span class="boring">        database.maintain()?;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    let contents = handle.access::&lt;&amp;CustomAsset&gt;(&amp;database).contents(&amp;database);
</span><span class="boring">    println!("Custom chain contents: {contents:?}");
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Custom asset type.
</span><span class="boring">#[derive(Debug, Default, Deserialize)]
</span><span class="boring">struct CustomAsset {
</span><span class="boring">    // Main content.
</span><span class="boring">    content: String,
</span><span class="boring">    // Optional sibling asset (content continuation).
</span><span class="boring">    #[serde(default)]
</span><span class="boring">    next: Option&lt;AssetPathStatic&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl CustomAsset {
</span><span class="boring">    fn contents(&amp;self, database: &amp;AssetDatabase) -&gt; String {
</span><span class="boring">        // Read this and it's siblings content to output.
</span><span class="boring">        let mut result = String::new();
</span><span class="boring">        let mut current = Some(self);
</span><span class="boring">        while let Some(asset) = current {
</span><span class="boring">            result.push_str(asset.content.as_str());
</span><span class="boring">            current = current
</span><span class="boring">                .as_ref()
</span><span class="boring">                .and_then(|asset| asset.next.as_ref())
</span><span class="boring">                .and_then(|path| path.find(database))
</span><span class="boring">                .and_then(|handle| handle.access_checked::&lt;&amp;Self&gt;(database));
</span><span class="boring">            if current.is_some() {
</span><span class="boring">                result.push(' ');
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        result
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>struct CustomAssetProcessor;

impl BundleWithDependenciesProcessor for CustomAssetProcessor {
    // Bundle of asset components this asset processor produces from processed asset.
    type Bundle = (CustomAsset,);

    fn process_bytes(
        &amp;mut self,
        bytes: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
        let asset = serde_json::from_slice::&lt;CustomAsset&gt;(&amp;bytes)?;
        let dependency = asset.next.clone();
        // Return bundled components and optional dependency which will be additionally loaded.
        Ok(BundleWithDependencies::new((asset,)).maybe_dependency(dependency))
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="group"><a class="header" href="#group">Group</a></h1>
<p><code>GroupAssetProtocol</code> allows to load group of assets at once as its dependencies.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, path::AssetPath},
</span><span class="boring">    fetch::file::FileAssetFetch,
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::BundleAssetProtocol,
</span><span class="boring">        bytes::BytesAssetProtocol,
</span><span class="boring">        group::{GroupAsset, GroupAssetProtocol},
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde_json::Value;
</span><span class="boring">use std::error::Error;
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span>    let mut database = AssetDatabase::default()
        .with_protocol(TextAssetProtocol)
        .with_protocol(BytesAssetProtocol)
        .with_protocol(BundleAssetProtocol::new("json", |bytes: Vec&lt;u8&gt;| {
            Ok((serde_json::from_slice::&lt;Value&gt;(&amp;bytes)?,).into())
        }))
        // Group asset protocol stores paths to other assets that gets scheduled
        // for loading when group loads.
        .with_protocol(GroupAssetProtocol)
        .with_fetch(FileAssetFetch::default().with_root("resources"));

    let group = database.ensure("group://group.txt")?;
    println!("Group: {:#?}", group.access::&lt;&amp;GroupAsset&gt;(&amp;database));

    while database.is_busy() {
        database.maintain()?;
    }

    let lorem = database.ensure("text://lorem.txt")?;
    println!("Lorem Ipsum: {}", lorem.access::&lt;&amp;String&gt;(&amp;database));

    let json = database.ensure("json://person.json")?;
    println!("JSON: {:#}", json.access::&lt;&amp;Value&gt;(&amp;database));

    let trash = database.ensure("bytes://trash.bin")?;
    println!("Bytes: {:?}", trash.access::&lt;&amp;Vec&lt;u8&gt;&gt;(&amp;database));

    for dependency in group.dependencies(&amp;database) {
        println!(
            "Group dependency: {}",
            dependency.access::&lt;&amp;AssetPath&gt;(&amp;database)
        );
    }
<span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="real-life-scenarios"><a class="header" href="#real-life-scenarios">Real life scenarios</a></h1>
<p>Next sub-chapters gonna be a set of real life scenarios of problems to solve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-in-game-setup"><a class="header" href="#basic-in-game-setup">Basic in-game setup</a></h1>
<p>Here we will showcase a basic usage of <code>Keket</code> integrated with some application.
In this example we will use <a href="https://github.com/PsichiX/spitfire">Spitfire</a> crate.</p>
<details>
<summary>See `use` section</summary>
<pre><code class="language-rust ignore">use keket::{
    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
    protocol::{
        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
        group::GroupAssetProtocol,
        text::TextAssetProtocol,
    },
    third_party::anput::{
        commands::{CommandBuffer, InsertCommand, RemoveCommand},
        entity::Entity,
        world::{Relation, World},
    },
};
use serde::{Deserialize, Serialize};
use spitfire::prelude::*;
use std::{
    error::Error,
    sync::{Arc, RwLock},
    time::Instant,
};
<span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    App::&lt;Vertex&gt;::default().run(State::default());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span><span class="boring">struct State {
</span><span class="boring">    // We store drawing context for later use in app state.
</span><span class="boring">    // Drawing context holds resources and stack-based states.
</span><span class="boring">    context: DrawContext,
</span><span class="boring">    // Timer used for fixed step frame particle system simulation.
</span><span class="boring">    timer: Instant,
</span><span class="boring">    assets: AssetDatabase,
</span><span class="boring">    image_shader: AssetRef,
</span><span class="boring">    ferris_texture: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for State {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            context: Default::default(),
</span><span class="boring">            timer: Instant::now(),
</span><span class="boring">            assets: AssetDatabase::default()
</span><span class="boring">                // Text protocol for shader sources.
</span><span class="boring">                .with_protocol(TextAssetProtocol)
</span><span class="boring">                // Group protocol for loading many assets at once.
</span><span class="boring">                .with_protocol(GroupAssetProtocol)
</span><span class="boring">                // Custom shader protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
</span><span class="boring">                // Custom texture protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
</span><span class="boring">                // Load all data from file system asynchronously.
</span><span class="boring">                .with_fetch(DeferredAssetFetch::new(
</span><span class="boring">                    FileAssetFetch::default().with_root("resources"),
</span><span class="boring">                )),
</span><span class="boring">            // Stored asset references for cached asset handles.
</span><span class="boring">            image_shader: AssetRef::new("shader://image.shader"),
</span><span class="boring">            ferris_texture: AssetRef::new("texture://ferris.png"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AppState&lt;Vertex&gt; for State {
</span><span class="boring">    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Setup scene camera.
</span><span class="boring">        graphics.color = [0.25, 0.25, 0.25, 1.0];
</span><span class="boring">        graphics.main_camera.screen_alignment = 0.5.into();
</span><span class="boring">        graphics.main_camera.scaling = CameraScaling::FitToView {
</span><span class="boring">            size: 1000.0.into(),
</span><span class="boring">            inside: false,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Load this scene group.
</span><span class="boring">        self.assets.ensure("group://ingame.txt").unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Process assets periotically.
</span><span class="boring">        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
</span><span class="boring">            self.timer = Instant::now();
</span><span class="boring">            self.process_assets(graphics);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Do not render unless we have shader loaded.
</span><span class="boring">        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">        let Some(image_shader) = image_shader
</span><span class="boring">            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
</span><span class="boring">            .map(|handle| handle.to_ref())
</span><span class="boring">        else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Begin drawing objects.
</span><span class="boring">        self.context.begin_frame(graphics);
</span><span class="boring">        self.context.push_shader(&amp;image_shader);
</span><span class="boring">        self.context.push_blending(GlowBlending::Alpha);
</span><span class="boring">
</span><span class="boring">        // Draw sprite only if texture asset is loaded.
</span><span class="boring">        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
</span><span class="boring">            if let Some(texture) = texture
</span><span class="boring">                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
</span><span class="boring">                .map(|handle| handle.to_ref())
</span><span class="boring">            {
</span><span class="boring">                Sprite::single(SpriteTexture::new("u_image".into(), texture))
</span><span class="boring">                    .pivot(0.5.into())
</span><span class="boring">                    .draw(&amp;mut self.context, graphics);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Commit drawn objects.
</span><span class="boring">        self.context.end_frame();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl State {
</span><span class="boring">    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">
</span><span class="boring">        // Process loaded shader assets into shader objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, ShaderAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
</span><span class="boring">            println!("* Shader asset turned into shader: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Process loaded texture assets into texture objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, TextureAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let texture = graphics
</span><span class="boring">                .texture(
</span><span class="boring">                    asset.width,
</span><span class="boring">                    asset.height,
</span><span class="boring">                    1,
</span><span class="boring">                    GlowTextureFormat::Rgba,
</span><span class="boring">                    Some(&amp;asset.bytes),
</span><span class="boring">                )
</span><span class="boring">                .unwrap();
</span><span class="boring">            println!("* Texture asset turned into texture: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        commands.execute(&amp;mut self.assets.storage);
</span><span class="boring">        self.assets.maintain().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded shader asset information with dependencies.
</span><span class="boring">#[derive(Debug, Serialize, Deserialize)]
</span><span class="boring">struct ShaderAssetInfo {
</span><span class="boring">    vertex: AssetRef,
</span><span class="boring">    fragment: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset with vertex and fragment programs code.
</span><span class="boring">struct ShaderAsset {
</span><span class="boring">    vertex: String,
</span><span class="boring">    fragment: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
</span><span class="boring">struct ShaderAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
</span><span class="boring">    type Bundle = (ShaderAssetInfo,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
</span><span class="boring">        let vertex = asset.vertex.path().clone();
</span><span class="boring">        let fragment = asset.fragment.path().clone();
</span><span class="boring">
</span><span class="boring">        println!("* Shader asset processed: {asset:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,))
</span><span class="boring">            .dependency(vertex)
</span><span class="boring">            .dependency(fragment))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();
</span><span class="boring">
</span><span class="boring">        // We scan for decoded shader info and if dependencies are loaded,
</span><span class="boring">        // then turn them into shader asset.
</span><span class="boring">        for (entity, info, dependencies) in
</span><span class="boring">            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
</span><span class="boring">        {
</span><span class="boring">            if dependencies
</span><span class="boring">                .entities()
</span><span class="boring">                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
</span><span class="boring">            {
</span><span class="boring">                let vertex = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">                let fragment = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">
</span><span class="boring">                let asset = ShaderAsset { vertex, fragment };
</span><span class="boring">                commands.command(InsertCommand::new(entity, (asset,)));
</span><span class="boring">                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        drop(lookup);
</span><span class="boring">
</span><span class="boring">        commands.execute(storage);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded texture asset with its size and decoded bitmap bytes.
</span><span class="boring">struct TextureAsset {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    bytes: Vec&lt;u8&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct TextureAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for TextureAssetProcessor {
</span><span class="boring">    type Bundle = (TextureAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        // Decode PNG image into texture size and bitmap bytes.
</span><span class="boring">        let decoder = png::Decoder::new(bytes.as_slice());
</span><span class="boring">        let mut reader = decoder.read_info()?;
</span><span class="boring">        let mut buf = vec![0; reader.output_buffer_size()];
</span><span class="boring">        let info = reader.next_frame(&amp;mut buf)?;
</span><span class="boring">        let bytes = buf[..info.buffer_size()].to_vec();
</span><span class="boring">
</span><span class="boring">        println!("* Texture asset processed: {info:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((TextureAsset {
</span><span class="boring">            width: info.width,
</span><span class="boring">            height: info.height,
</span><span class="boring">            bytes,
</span><span class="boring">        },)))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
</details>
<h2 id="main-function"><a class="header" href="#main-function">Main function</a></h2>
<p>Main function looks boring - all we do is we run <code>App</code> with <code>State</code> object.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
</span><span class="boring">        group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">    third_party::anput::{
</span><span class="boring">        commands::{CommandBuffer, InsertCommand, RemoveCommand},
</span><span class="boring">        entity::Entity,
</span><span class="boring">        world::{Relation, World},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use spitfire::prelude::*;
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">    time::Instant,
</span><span class="boring">};
</span><span class="boring">
</span>fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    App::&lt;Vertex&gt;::default().run(State::default());

    Ok(())
}
<span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span><span class="boring">struct State {
</span><span class="boring">    // We store drawing context for later use in app state.
</span><span class="boring">    // Drawing context holds resources and stack-based states.
</span><span class="boring">    context: DrawContext,
</span><span class="boring">    // Timer used for fixed step frame particle system simulation.
</span><span class="boring">    timer: Instant,
</span><span class="boring">    assets: AssetDatabase,
</span><span class="boring">    image_shader: AssetRef,
</span><span class="boring">    ferris_texture: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for State {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            context: Default::default(),
</span><span class="boring">            timer: Instant::now(),
</span><span class="boring">            assets: AssetDatabase::default()
</span><span class="boring">                // Text protocol for shader sources.
</span><span class="boring">                .with_protocol(TextAssetProtocol)
</span><span class="boring">                // Group protocol for loading many assets at once.
</span><span class="boring">                .with_protocol(GroupAssetProtocol)
</span><span class="boring">                // Custom shader protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
</span><span class="boring">                // Custom texture protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
</span><span class="boring">                // Load all data from file system asynchronously.
</span><span class="boring">                .with_fetch(DeferredAssetFetch::new(
</span><span class="boring">                    FileAssetFetch::default().with_root("resources"),
</span><span class="boring">                )),
</span><span class="boring">            // Stored asset references for cached asset handles.
</span><span class="boring">            image_shader: AssetRef::new("shader://image.shader"),
</span><span class="boring">            ferris_texture: AssetRef::new("texture://ferris.png"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AppState&lt;Vertex&gt; for State {
</span><span class="boring">    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Setup scene camera.
</span><span class="boring">        graphics.color = [0.25, 0.25, 0.25, 1.0];
</span><span class="boring">        graphics.main_camera.screen_alignment = 0.5.into();
</span><span class="boring">        graphics.main_camera.scaling = CameraScaling::FitToView {
</span><span class="boring">            size: 1000.0.into(),
</span><span class="boring">            inside: false,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Load this scene group.
</span><span class="boring">        self.assets.ensure("group://ingame.txt").unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Process assets periotically.
</span><span class="boring">        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
</span><span class="boring">            self.timer = Instant::now();
</span><span class="boring">            self.process_assets(graphics);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Do not render unless we have shader loaded.
</span><span class="boring">        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">        let Some(image_shader) = image_shader
</span><span class="boring">            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
</span><span class="boring">            .map(|handle| handle.to_ref())
</span><span class="boring">        else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Begin drawing objects.
</span><span class="boring">        self.context.begin_frame(graphics);
</span><span class="boring">        self.context.push_shader(&amp;image_shader);
</span><span class="boring">        self.context.push_blending(GlowBlending::Alpha);
</span><span class="boring">
</span><span class="boring">        // Draw sprite only if texture asset is loaded.
</span><span class="boring">        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
</span><span class="boring">            if let Some(texture) = texture
</span><span class="boring">                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
</span><span class="boring">                .map(|handle| handle.to_ref())
</span><span class="boring">            {
</span><span class="boring">                Sprite::single(SpriteTexture::new("u_image".into(), texture))
</span><span class="boring">                    .pivot(0.5.into())
</span><span class="boring">                    .draw(&amp;mut self.context, graphics);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Commit drawn objects.
</span><span class="boring">        self.context.end_frame();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl State {
</span><span class="boring">    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">
</span><span class="boring">        // Process loaded shader assets into shader objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, ShaderAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
</span><span class="boring">            println!("* Shader asset turned into shader: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Process loaded texture assets into texture objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, TextureAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let texture = graphics
</span><span class="boring">                .texture(
</span><span class="boring">                    asset.width,
</span><span class="boring">                    asset.height,
</span><span class="boring">                    1,
</span><span class="boring">                    GlowTextureFormat::Rgba,
</span><span class="boring">                    Some(&amp;asset.bytes),
</span><span class="boring">                )
</span><span class="boring">                .unwrap();
</span><span class="boring">            println!("* Texture asset turned into texture: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        commands.execute(&amp;mut self.assets.storage);
</span><span class="boring">        self.assets.maintain().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded shader asset information with dependencies.
</span><span class="boring">#[derive(Debug, Serialize, Deserialize)]
</span><span class="boring">struct ShaderAssetInfo {
</span><span class="boring">    vertex: AssetRef,
</span><span class="boring">    fragment: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset with vertex and fragment programs code.
</span><span class="boring">struct ShaderAsset {
</span><span class="boring">    vertex: String,
</span><span class="boring">    fragment: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
</span><span class="boring">struct ShaderAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
</span><span class="boring">    type Bundle = (ShaderAssetInfo,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
</span><span class="boring">        let vertex = asset.vertex.path().clone();
</span><span class="boring">        let fragment = asset.fragment.path().clone();
</span><span class="boring">
</span><span class="boring">        println!("* Shader asset processed: {asset:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,))
</span><span class="boring">            .dependency(vertex)
</span><span class="boring">            .dependency(fragment))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();
</span><span class="boring">
</span><span class="boring">        // We scan for decoded shader info and if dependencies are loaded,
</span><span class="boring">        // then turn them into shader asset.
</span><span class="boring">        for (entity, info, dependencies) in
</span><span class="boring">            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
</span><span class="boring">        {
</span><span class="boring">            if dependencies
</span><span class="boring">                .entities()
</span><span class="boring">                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
</span><span class="boring">            {
</span><span class="boring">                let vertex = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">                let fragment = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">
</span><span class="boring">                let asset = ShaderAsset { vertex, fragment };
</span><span class="boring">                commands.command(InsertCommand::new(entity, (asset,)));
</span><span class="boring">                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        drop(lookup);
</span><span class="boring">
</span><span class="boring">        commands.execute(storage);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded texture asset with its size and decoded bitmap bytes.
</span><span class="boring">struct TextureAsset {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    bytes: Vec&lt;u8&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct TextureAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for TextureAssetProcessor {
</span><span class="boring">    type Bundle = (TextureAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        // Decode PNG image into texture size and bitmap bytes.
</span><span class="boring">        let decoder = png::Decoder::new(bytes.as_slice());
</span><span class="boring">        let mut reader = decoder.read_info()?;
</span><span class="boring">        let mut buf = vec![0; reader.output_buffer_size()];
</span><span class="boring">        let info = reader.next_frame(&amp;mut buf)?;
</span><span class="boring">        let bytes = buf[..info.buffer_size()].to_vec();
</span><span class="boring">
</span><span class="boring">        println!("* Texture asset processed: {info:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((TextureAsset {
</span><span class="boring">            width: info.width,
</span><span class="boring">            height: info.height,
</span><span class="boring">            bytes,
</span><span class="boring">        },)))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="state-struct"><a class="header" href="#state-struct">State struct</a></h2>
<p><code>State</code> type holds <code>AssetDatabase</code> along with some other data useful for drawing,
fixed time step mechanism and referencing assets.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
</span><span class="boring">        group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">    third_party::anput::{
</span><span class="boring">        commands::{CommandBuffer, InsertCommand, RemoveCommand},
</span><span class="boring">        entity::Entity,
</span><span class="boring">        world::{Relation, World},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use spitfire::prelude::*;
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">    time::Instant,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    App::&lt;Vertex&gt;::default().run(State::default());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span>struct State {
    // We store drawing context for later use in app state.
    // Drawing context holds resources and stack-based states.
    context: DrawContext,
    // Timer used for fixed step frame particle system simulation.
    timer: Instant,
    assets: AssetDatabase,
    image_shader: AssetRef,
    ferris_texture: AssetRef,
}
<span class="boring">
</span><span class="boring">impl Default for State {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            context: Default::default(),
</span><span class="boring">            timer: Instant::now(),
</span><span class="boring">            assets: AssetDatabase::default()
</span><span class="boring">                // Text protocol for shader sources.
</span><span class="boring">                .with_protocol(TextAssetProtocol)
</span><span class="boring">                // Group protocol for loading many assets at once.
</span><span class="boring">                .with_protocol(GroupAssetProtocol)
</span><span class="boring">                // Custom shader protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
</span><span class="boring">                // Custom texture protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
</span><span class="boring">                // Load all data from file system asynchronously.
</span><span class="boring">                .with_fetch(DeferredAssetFetch::new(
</span><span class="boring">                    FileAssetFetch::default().with_root("resources"),
</span><span class="boring">                )),
</span><span class="boring">            // Stored asset references for cached asset handles.
</span><span class="boring">            image_shader: AssetRef::new("shader://image.shader"),
</span><span class="boring">            ferris_texture: AssetRef::new("texture://ferris.png"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AppState&lt;Vertex&gt; for State {
</span><span class="boring">    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Setup scene camera.
</span><span class="boring">        graphics.color = [0.25, 0.25, 0.25, 1.0];
</span><span class="boring">        graphics.main_camera.screen_alignment = 0.5.into();
</span><span class="boring">        graphics.main_camera.scaling = CameraScaling::FitToView {
</span><span class="boring">            size: 1000.0.into(),
</span><span class="boring">            inside: false,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Load this scene group.
</span><span class="boring">        self.assets.ensure("group://ingame.txt").unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Process assets periotically.
</span><span class="boring">        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
</span><span class="boring">            self.timer = Instant::now();
</span><span class="boring">            self.process_assets(graphics);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Do not render unless we have shader loaded.
</span><span class="boring">        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">        let Some(image_shader) = image_shader
</span><span class="boring">            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
</span><span class="boring">            .map(|handle| handle.to_ref())
</span><span class="boring">        else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Begin drawing objects.
</span><span class="boring">        self.context.begin_frame(graphics);
</span><span class="boring">        self.context.push_shader(&amp;image_shader);
</span><span class="boring">        self.context.push_blending(GlowBlending::Alpha);
</span><span class="boring">
</span><span class="boring">        // Draw sprite only if texture asset is loaded.
</span><span class="boring">        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
</span><span class="boring">            if let Some(texture) = texture
</span><span class="boring">                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
</span><span class="boring">                .map(|handle| handle.to_ref())
</span><span class="boring">            {
</span><span class="boring">                Sprite::single(SpriteTexture::new("u_image".into(), texture))
</span><span class="boring">                    .pivot(0.5.into())
</span><span class="boring">                    .draw(&amp;mut self.context, graphics);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Commit drawn objects.
</span><span class="boring">        self.context.end_frame();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl State {
</span><span class="boring">    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">
</span><span class="boring">        // Process loaded shader assets into shader objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, ShaderAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
</span><span class="boring">            println!("* Shader asset turned into shader: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Process loaded texture assets into texture objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, TextureAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let texture = graphics
</span><span class="boring">                .texture(
</span><span class="boring">                    asset.width,
</span><span class="boring">                    asset.height,
</span><span class="boring">                    1,
</span><span class="boring">                    GlowTextureFormat::Rgba,
</span><span class="boring">                    Some(&amp;asset.bytes),
</span><span class="boring">                )
</span><span class="boring">                .unwrap();
</span><span class="boring">            println!("* Texture asset turned into texture: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        commands.execute(&amp;mut self.assets.storage);
</span><span class="boring">        self.assets.maintain().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded shader asset information with dependencies.
</span><span class="boring">#[derive(Debug, Serialize, Deserialize)]
</span><span class="boring">struct ShaderAssetInfo {
</span><span class="boring">    vertex: AssetRef,
</span><span class="boring">    fragment: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset with vertex and fragment programs code.
</span><span class="boring">struct ShaderAsset {
</span><span class="boring">    vertex: String,
</span><span class="boring">    fragment: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
</span><span class="boring">struct ShaderAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
</span><span class="boring">    type Bundle = (ShaderAssetInfo,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
</span><span class="boring">        let vertex = asset.vertex.path().clone();
</span><span class="boring">        let fragment = asset.fragment.path().clone();
</span><span class="boring">
</span><span class="boring">        println!("* Shader asset processed: {asset:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,))
</span><span class="boring">            .dependency(vertex)
</span><span class="boring">            .dependency(fragment))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();
</span><span class="boring">
</span><span class="boring">        // We scan for decoded shader info and if dependencies are loaded,
</span><span class="boring">        // then turn them into shader asset.
</span><span class="boring">        for (entity, info, dependencies) in
</span><span class="boring">            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
</span><span class="boring">        {
</span><span class="boring">            if dependencies
</span><span class="boring">                .entities()
</span><span class="boring">                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
</span><span class="boring">            {
</span><span class="boring">                let vertex = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">                let fragment = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">
</span><span class="boring">                let asset = ShaderAsset { vertex, fragment };
</span><span class="boring">                commands.command(InsertCommand::new(entity, (asset,)));
</span><span class="boring">                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        drop(lookup);
</span><span class="boring">
</span><span class="boring">        commands.execute(storage);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded texture asset with its size and decoded bitmap bytes.
</span><span class="boring">struct TextureAsset {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    bytes: Vec&lt;u8&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct TextureAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for TextureAssetProcessor {
</span><span class="boring">    type Bundle = (TextureAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        // Decode PNG image into texture size and bitmap bytes.
</span><span class="boring">        let decoder = png::Decoder::new(bytes.as_slice());
</span><span class="boring">        let mut reader = decoder.read_info()?;
</span><span class="boring">        let mut buf = vec![0; reader.output_buffer_size()];
</span><span class="boring">        let info = reader.next_frame(&amp;mut buf)?;
</span><span class="boring">        let bytes = buf[..info.buffer_size()].to_vec();
</span><span class="boring">
</span><span class="boring">        println!("* Texture asset processed: {info:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((TextureAsset {
</span><span class="boring">            width: info.width,
</span><span class="boring">            height: info.height,
</span><span class="boring">            bytes,
</span><span class="boring">        },)))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="state-default-impl"><a class="header" href="#state-default-impl">State <code>Default</code> impl</a></h2>
<p>In <code>Default</code> implementatio we setup app state.</p>
<p>Take a look at how we setup <code>AssetDatabase</code> protocols:</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
</span><span class="boring">        group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">    third_party::anput::{
</span><span class="boring">        commands::{CommandBuffer, InsertCommand, RemoveCommand},
</span><span class="boring">        entity::Entity,
</span><span class="boring">        world::{Relation, World},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use spitfire::prelude::*;
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">    time::Instant,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    App::&lt;Vertex&gt;::default().run(State::default());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span><span class="boring">struct State {
</span><span class="boring">    // We store drawing context for later use in app state.
</span><span class="boring">    // Drawing context holds resources and stack-based states.
</span><span class="boring">    context: DrawContext,
</span><span class="boring">    // Timer used for fixed step frame particle system simulation.
</span><span class="boring">    timer: Instant,
</span><span class="boring">    assets: AssetDatabase,
</span><span class="boring">    image_shader: AssetRef,
</span><span class="boring">    ferris_texture: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span>impl Default for State {
    fn default() -&gt; Self {
        Self {
            context: Default::default(),
            timer: Instant::now(),
            assets: AssetDatabase::default()
                // Text protocol for shader sources.
                .with_protocol(TextAssetProtocol)
                // Group protocol for loading many assets at once.
                .with_protocol(GroupAssetProtocol)
                // Custom shader protocol.
                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
                // Custom texture protocol.
                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
                // Load all data from file system asynchronously.
                .with_fetch(DeferredAssetFetch::new(
                    FileAssetFetch::default().with_root("resources"),
                )),
            // Stored asset references for cached asset handles.
            image_shader: AssetRef::new("shader://image.shader"),
            ferris_texture: AssetRef::new("texture://ferris.png"),
        }
    }
}
<span class="boring">
</span><span class="boring">impl AppState&lt;Vertex&gt; for State {
</span><span class="boring">    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Setup scene camera.
</span><span class="boring">        graphics.color = [0.25, 0.25, 0.25, 1.0];
</span><span class="boring">        graphics.main_camera.screen_alignment = 0.5.into();
</span><span class="boring">        graphics.main_camera.scaling = CameraScaling::FitToView {
</span><span class="boring">            size: 1000.0.into(),
</span><span class="boring">            inside: false,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Load this scene group.
</span><span class="boring">        self.assets.ensure("group://ingame.txt").unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Process assets periotically.
</span><span class="boring">        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
</span><span class="boring">            self.timer = Instant::now();
</span><span class="boring">            self.process_assets(graphics);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Do not render unless we have shader loaded.
</span><span class="boring">        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">        let Some(image_shader) = image_shader
</span><span class="boring">            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
</span><span class="boring">            .map(|handle| handle.to_ref())
</span><span class="boring">        else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Begin drawing objects.
</span><span class="boring">        self.context.begin_frame(graphics);
</span><span class="boring">        self.context.push_shader(&amp;image_shader);
</span><span class="boring">        self.context.push_blending(GlowBlending::Alpha);
</span><span class="boring">
</span><span class="boring">        // Draw sprite only if texture asset is loaded.
</span><span class="boring">        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
</span><span class="boring">            if let Some(texture) = texture
</span><span class="boring">                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
</span><span class="boring">                .map(|handle| handle.to_ref())
</span><span class="boring">            {
</span><span class="boring">                Sprite::single(SpriteTexture::new("u_image".into(), texture))
</span><span class="boring">                    .pivot(0.5.into())
</span><span class="boring">                    .draw(&amp;mut self.context, graphics);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Commit drawn objects.
</span><span class="boring">        self.context.end_frame();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl State {
</span><span class="boring">    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">
</span><span class="boring">        // Process loaded shader assets into shader objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, ShaderAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
</span><span class="boring">            println!("* Shader asset turned into shader: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Process loaded texture assets into texture objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, TextureAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let texture = graphics
</span><span class="boring">                .texture(
</span><span class="boring">                    asset.width,
</span><span class="boring">                    asset.height,
</span><span class="boring">                    1,
</span><span class="boring">                    GlowTextureFormat::Rgba,
</span><span class="boring">                    Some(&amp;asset.bytes),
</span><span class="boring">                )
</span><span class="boring">                .unwrap();
</span><span class="boring">            println!("* Texture asset turned into texture: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        commands.execute(&amp;mut self.assets.storage);
</span><span class="boring">        self.assets.maintain().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded shader asset information with dependencies.
</span><span class="boring">#[derive(Debug, Serialize, Deserialize)]
</span><span class="boring">struct ShaderAssetInfo {
</span><span class="boring">    vertex: AssetRef,
</span><span class="boring">    fragment: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset with vertex and fragment programs code.
</span><span class="boring">struct ShaderAsset {
</span><span class="boring">    vertex: String,
</span><span class="boring">    fragment: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
</span><span class="boring">struct ShaderAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
</span><span class="boring">    type Bundle = (ShaderAssetInfo,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
</span><span class="boring">        let vertex = asset.vertex.path().clone();
</span><span class="boring">        let fragment = asset.fragment.path().clone();
</span><span class="boring">
</span><span class="boring">        println!("* Shader asset processed: {asset:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,))
</span><span class="boring">            .dependency(vertex)
</span><span class="boring">            .dependency(fragment))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();
</span><span class="boring">
</span><span class="boring">        // We scan for decoded shader info and if dependencies are loaded,
</span><span class="boring">        // then turn them into shader asset.
</span><span class="boring">        for (entity, info, dependencies) in
</span><span class="boring">            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
</span><span class="boring">        {
</span><span class="boring">            if dependencies
</span><span class="boring">                .entities()
</span><span class="boring">                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
</span><span class="boring">            {
</span><span class="boring">                let vertex = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">                let fragment = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">
</span><span class="boring">                let asset = ShaderAsset { vertex, fragment };
</span><span class="boring">                commands.command(InsertCommand::new(entity, (asset,)));
</span><span class="boring">                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        drop(lookup);
</span><span class="boring">
</span><span class="boring">        commands.execute(storage);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded texture asset with its size and decoded bitmap bytes.
</span><span class="boring">struct TextureAsset {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    bytes: Vec&lt;u8&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct TextureAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for TextureAssetProcessor {
</span><span class="boring">    type Bundle = (TextureAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        // Decode PNG image into texture size and bitmap bytes.
</span><span class="boring">        let decoder = png::Decoder::new(bytes.as_slice());
</span><span class="boring">        let mut reader = decoder.read_info()?;
</span><span class="boring">        let mut buf = vec![0; reader.output_buffer_size()];
</span><span class="boring">        let info = reader.next_frame(&amp;mut buf)?;
</span><span class="boring">        let bytes = buf[..info.buffer_size()].to_vec();
</span><span class="boring">
</span><span class="boring">        println!("* Texture asset processed: {info:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((TextureAsset {
</span><span class="boring">            width: info.width,
</span><span class="boring">            height: info.height,
</span><span class="boring">            bytes,
</span><span class="boring">        },)))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>In there you can see bundle asset protocols wrapping custom shader and texture
asset processors.</p>
<h2 id="state-appstate-impl"><a class="header" href="#state-appstate-impl">State <code>AppState</code> impl</a></h2>
<p>Then we implement <code>AppState</code> for our <code>State</code> type, where in <code>on_init</code> we setup
graphics and load scene group asset, and in <code>on_redraw</code> we run asset database
maintanance periodically and then try to render Ferris sprite only if shader and
texture assets are ready.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
</span><span class="boring">        group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">    third_party::anput::{
</span><span class="boring">        commands::{CommandBuffer, InsertCommand, RemoveCommand},
</span><span class="boring">        entity::Entity,
</span><span class="boring">        world::{Relation, World},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use spitfire::prelude::*;
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">    time::Instant,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    App::&lt;Vertex&gt;::default().run(State::default());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span><span class="boring">struct State {
</span><span class="boring">    // We store drawing context for later use in app state.
</span><span class="boring">    // Drawing context holds resources and stack-based states.
</span><span class="boring">    context: DrawContext,
</span><span class="boring">    // Timer used for fixed step frame particle system simulation.
</span><span class="boring">    timer: Instant,
</span><span class="boring">    assets: AssetDatabase,
</span><span class="boring">    image_shader: AssetRef,
</span><span class="boring">    ferris_texture: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for State {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            context: Default::default(),
</span><span class="boring">            timer: Instant::now(),
</span><span class="boring">            assets: AssetDatabase::default()
</span><span class="boring">                // Text protocol for shader sources.
</span><span class="boring">                .with_protocol(TextAssetProtocol)
</span><span class="boring">                // Group protocol for loading many assets at once.
</span><span class="boring">                .with_protocol(GroupAssetProtocol)
</span><span class="boring">                // Custom shader protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
</span><span class="boring">                // Custom texture protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
</span><span class="boring">                // Load all data from file system asynchronously.
</span><span class="boring">                .with_fetch(DeferredAssetFetch::new(
</span><span class="boring">                    FileAssetFetch::default().with_root("resources"),
</span><span class="boring">                )),
</span><span class="boring">            // Stored asset references for cached asset handles.
</span><span class="boring">            image_shader: AssetRef::new("shader://image.shader"),
</span><span class="boring">            ferris_texture: AssetRef::new("texture://ferris.png"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl AppState&lt;Vertex&gt; for State {
    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
        // Setup scene camera.
        graphics.color = [0.25, 0.25, 0.25, 1.0];
        graphics.main_camera.screen_alignment = 0.5.into();
        graphics.main_camera.scaling = CameraScaling::FitToView {
            size: 1000.0.into(),
            inside: false,
        };

        // Load this scene group.
        self.assets.ensure("group://ingame.txt").unwrap();
    }

    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
        // Process assets periotically.
        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
            self.timer = Instant::now();
            self.process_assets(graphics);
        }

        // Do not render unless we have shader loaded.
        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
            return;
        };
        let Some(image_shader) = image_shader
            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
            .map(|handle| handle.to_ref())
        else {
            return;
        };

        // Begin drawing objects.
        self.context.begin_frame(graphics);
        self.context.push_shader(&amp;image_shader);
        self.context.push_blending(GlowBlending::Alpha);

        // Draw sprite only if texture asset is loaded.
        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
            if let Some(texture) = texture
                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
                .map(|handle| handle.to_ref())
            {
                Sprite::single(SpriteTexture::new("u_image".into(), texture))
                    .pivot(0.5.into())
                    .draw(&amp;mut self.context, graphics);
            }
        }

        // Commit drawn objects.
        self.context.end_frame();
    }
}
<span class="boring">
</span><span class="boring">impl State {
</span><span class="boring">    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">
</span><span class="boring">        // Process loaded shader assets into shader objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, ShaderAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
</span><span class="boring">            println!("* Shader asset turned into shader: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Process loaded texture assets into texture objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, TextureAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let texture = graphics
</span><span class="boring">                .texture(
</span><span class="boring">                    asset.width,
</span><span class="boring">                    asset.height,
</span><span class="boring">                    1,
</span><span class="boring">                    GlowTextureFormat::Rgba,
</span><span class="boring">                    Some(&amp;asset.bytes),
</span><span class="boring">                )
</span><span class="boring">                .unwrap();
</span><span class="boring">            println!("* Texture asset turned into texture: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        commands.execute(&amp;mut self.assets.storage);
</span><span class="boring">        self.assets.maintain().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded shader asset information with dependencies.
</span><span class="boring">#[derive(Debug, Serialize, Deserialize)]
</span><span class="boring">struct ShaderAssetInfo {
</span><span class="boring">    vertex: AssetRef,
</span><span class="boring">    fragment: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset with vertex and fragment programs code.
</span><span class="boring">struct ShaderAsset {
</span><span class="boring">    vertex: String,
</span><span class="boring">    fragment: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
</span><span class="boring">struct ShaderAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
</span><span class="boring">    type Bundle = (ShaderAssetInfo,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
</span><span class="boring">        let vertex = asset.vertex.path().clone();
</span><span class="boring">        let fragment = asset.fragment.path().clone();
</span><span class="boring">
</span><span class="boring">        println!("* Shader asset processed: {asset:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,))
</span><span class="boring">            .dependency(vertex)
</span><span class="boring">            .dependency(fragment))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();
</span><span class="boring">
</span><span class="boring">        // We scan for decoded shader info and if dependencies are loaded,
</span><span class="boring">        // then turn them into shader asset.
</span><span class="boring">        for (entity, info, dependencies) in
</span><span class="boring">            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
</span><span class="boring">        {
</span><span class="boring">            if dependencies
</span><span class="boring">                .entities()
</span><span class="boring">                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
</span><span class="boring">            {
</span><span class="boring">                let vertex = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">                let fragment = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">
</span><span class="boring">                let asset = ShaderAsset { vertex, fragment };
</span><span class="boring">                commands.command(InsertCommand::new(entity, (asset,)));
</span><span class="boring">                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        drop(lookup);
</span><span class="boring">
</span><span class="boring">        commands.execute(storage);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded texture asset with its size and decoded bitmap bytes.
</span><span class="boring">struct TextureAsset {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    bytes: Vec&lt;u8&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct TextureAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for TextureAssetProcessor {
</span><span class="boring">    type Bundle = (TextureAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        // Decode PNG image into texture size and bitmap bytes.
</span><span class="boring">        let decoder = png::Decoder::new(bytes.as_slice());
</span><span class="boring">        let mut reader = decoder.read_info()?;
</span><span class="boring">        let mut buf = vec![0; reader.output_buffer_size()];
</span><span class="boring">        let info = reader.next_frame(&amp;mut buf)?;
</span><span class="boring">        let bytes = buf[..info.buffer_size()].to_vec();
</span><span class="boring">
</span><span class="boring">        println!("* Texture asset processed: {info:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((TextureAsset {
</span><span class="boring">            width: info.width,
</span><span class="boring">            height: info.height,
</span><span class="boring">            bytes,
</span><span class="boring">        },)))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="state-impl"><a class="header" href="#state-impl">State impl</a></h2>
<p>In <code>State</code> implementation we finally do our first interesting bit - since asset
protocols does not have access to our state, we can process prepared shader and
texture assets and then build GPU objects for these assets and put them into
their assets.</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
</span><span class="boring">        group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">    third_party::anput::{
</span><span class="boring">        commands::{CommandBuffer, InsertCommand, RemoveCommand},
</span><span class="boring">        entity::Entity,
</span><span class="boring">        world::{Relation, World},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use spitfire::prelude::*;
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">    time::Instant,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    App::&lt;Vertex&gt;::default().run(State::default());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span><span class="boring">struct State {
</span><span class="boring">    // We store drawing context for later use in app state.
</span><span class="boring">    // Drawing context holds resources and stack-based states.
</span><span class="boring">    context: DrawContext,
</span><span class="boring">    // Timer used for fixed step frame particle system simulation.
</span><span class="boring">    timer: Instant,
</span><span class="boring">    assets: AssetDatabase,
</span><span class="boring">    image_shader: AssetRef,
</span><span class="boring">    ferris_texture: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for State {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            context: Default::default(),
</span><span class="boring">            timer: Instant::now(),
</span><span class="boring">            assets: AssetDatabase::default()
</span><span class="boring">                // Text protocol for shader sources.
</span><span class="boring">                .with_protocol(TextAssetProtocol)
</span><span class="boring">                // Group protocol for loading many assets at once.
</span><span class="boring">                .with_protocol(GroupAssetProtocol)
</span><span class="boring">                // Custom shader protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
</span><span class="boring">                // Custom texture protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
</span><span class="boring">                // Load all data from file system asynchronously.
</span><span class="boring">                .with_fetch(DeferredAssetFetch::new(
</span><span class="boring">                    FileAssetFetch::default().with_root("resources"),
</span><span class="boring">                )),
</span><span class="boring">            // Stored asset references for cached asset handles.
</span><span class="boring">            image_shader: AssetRef::new("shader://image.shader"),
</span><span class="boring">            ferris_texture: AssetRef::new("texture://ferris.png"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AppState&lt;Vertex&gt; for State {
</span><span class="boring">    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Setup scene camera.
</span><span class="boring">        graphics.color = [0.25, 0.25, 0.25, 1.0];
</span><span class="boring">        graphics.main_camera.screen_alignment = 0.5.into();
</span><span class="boring">        graphics.main_camera.scaling = CameraScaling::FitToView {
</span><span class="boring">            size: 1000.0.into(),
</span><span class="boring">            inside: false,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Load this scene group.
</span><span class="boring">        self.assets.ensure("group://ingame.txt").unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Process assets periotically.
</span><span class="boring">        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
</span><span class="boring">            self.timer = Instant::now();
</span><span class="boring">            self.process_assets(graphics);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Do not render unless we have shader loaded.
</span><span class="boring">        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">        let Some(image_shader) = image_shader
</span><span class="boring">            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
</span><span class="boring">            .map(|handle| handle.to_ref())
</span><span class="boring">        else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Begin drawing objects.
</span><span class="boring">        self.context.begin_frame(graphics);
</span><span class="boring">        self.context.push_shader(&amp;image_shader);
</span><span class="boring">        self.context.push_blending(GlowBlending::Alpha);
</span><span class="boring">
</span><span class="boring">        // Draw sprite only if texture asset is loaded.
</span><span class="boring">        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
</span><span class="boring">            if let Some(texture) = texture
</span><span class="boring">                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
</span><span class="boring">                .map(|handle| handle.to_ref())
</span><span class="boring">            {
</span><span class="boring">                Sprite::single(SpriteTexture::new("u_image".into(), texture))
</span><span class="boring">                    .pivot(0.5.into())
</span><span class="boring">                    .draw(&amp;mut self.context, graphics);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Commit drawn objects.
</span><span class="boring">        self.context.end_frame();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl State {
    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
        let mut commands = CommandBuffer::default();

        // Process loaded shader assets into shader objects on GPU.
        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
            let asset = self
                .assets
                .storage
                .component::&lt;true, ShaderAsset&gt;(entity)
                .unwrap();
            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
            println!("* Shader asset turned into shader: {entity}");
            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
        }

        // Process loaded texture assets into texture objects on GPU.
        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
            let asset = self
                .assets
                .storage
                .component::&lt;true, TextureAsset&gt;(entity)
                .unwrap();
            let texture = graphics
                .texture(
                    asset.width,
                    asset.height,
                    1,
                    GlowTextureFormat::Rgba,
                    Some(&amp;asset.bytes),
                )
                .unwrap();
            println!("* Texture asset turned into texture: {entity}");
            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
        }

        commands.execute(&amp;mut self.assets.storage);
        self.assets.maintain().unwrap();
    }
}
<span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded shader asset information with dependencies.
</span><span class="boring">#[derive(Debug, Serialize, Deserialize)]
</span><span class="boring">struct ShaderAssetInfo {
</span><span class="boring">    vertex: AssetRef,
</span><span class="boring">    fragment: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset with vertex and fragment programs code.
</span><span class="boring">struct ShaderAsset {
</span><span class="boring">    vertex: String,
</span><span class="boring">    fragment: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
</span><span class="boring">struct ShaderAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
</span><span class="boring">    type Bundle = (ShaderAssetInfo,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
</span><span class="boring">        let vertex = asset.vertex.path().clone();
</span><span class="boring">        let fragment = asset.fragment.path().clone();
</span><span class="boring">
</span><span class="boring">        println!("* Shader asset processed: {asset:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,))
</span><span class="boring">            .dependency(vertex)
</span><span class="boring">            .dependency(fragment))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();
</span><span class="boring">
</span><span class="boring">        // We scan for decoded shader info and if dependencies are loaded,
</span><span class="boring">        // then turn them into shader asset.
</span><span class="boring">        for (entity, info, dependencies) in
</span><span class="boring">            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
</span><span class="boring">        {
</span><span class="boring">            if dependencies
</span><span class="boring">                .entities()
</span><span class="boring">                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
</span><span class="boring">            {
</span><span class="boring">                let vertex = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">                let fragment = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">
</span><span class="boring">                let asset = ShaderAsset { vertex, fragment };
</span><span class="boring">                commands.command(InsertCommand::new(entity, (asset,)));
</span><span class="boring">                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        drop(lookup);
</span><span class="boring">
</span><span class="boring">        commands.execute(storage);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded texture asset with its size and decoded bitmap bytes.
</span><span class="boring">struct TextureAsset {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    bytes: Vec&lt;u8&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct TextureAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for TextureAssetProcessor {
</span><span class="boring">    type Bundle = (TextureAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        // Decode PNG image into texture size and bitmap bytes.
</span><span class="boring">        let decoder = png::Decoder::new(bytes.as_slice());
</span><span class="boring">        let mut reader = decoder.read_info()?;
</span><span class="boring">        let mut buf = vec![0; reader.output_buffer_size()];
</span><span class="boring">        let info = reader.next_frame(&amp;mut buf)?;
</span><span class="boring">        let bytes = buf[..info.buffer_size()].to_vec();
</span><span class="boring">
</span><span class="boring">        println!("* Texture asset processed: {info:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((TextureAsset {
</span><span class="boring">            width: info.width,
</span><span class="boring">            height: info.height,
</span><span class="boring">            bytes,
</span><span class="boring">        },)))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h2 id="texture-asset-processor"><a class="header" href="#texture-asset-processor">Texture asset processor</a></h2>
<p>Now let's see how we have made our texture asset processor:</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
</span><span class="boring">        group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">    third_party::anput::{
</span><span class="boring">        commands::{CommandBuffer, InsertCommand, RemoveCommand},
</span><span class="boring">        entity::Entity,
</span><span class="boring">        world::{Relation, World},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use spitfire::prelude::*;
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">    time::Instant,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    App::&lt;Vertex&gt;::default().run(State::default());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span><span class="boring">struct State {
</span><span class="boring">    // We store drawing context for later use in app state.
</span><span class="boring">    // Drawing context holds resources and stack-based states.
</span><span class="boring">    context: DrawContext,
</span><span class="boring">    // Timer used for fixed step frame particle system simulation.
</span><span class="boring">    timer: Instant,
</span><span class="boring">    assets: AssetDatabase,
</span><span class="boring">    image_shader: AssetRef,
</span><span class="boring">    ferris_texture: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for State {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            context: Default::default(),
</span><span class="boring">            timer: Instant::now(),
</span><span class="boring">            assets: AssetDatabase::default()
</span><span class="boring">                // Text protocol for shader sources.
</span><span class="boring">                .with_protocol(TextAssetProtocol)
</span><span class="boring">                // Group protocol for loading many assets at once.
</span><span class="boring">                .with_protocol(GroupAssetProtocol)
</span><span class="boring">                // Custom shader protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
</span><span class="boring">                // Custom texture protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
</span><span class="boring">                // Load all data from file system asynchronously.
</span><span class="boring">                .with_fetch(DeferredAssetFetch::new(
</span><span class="boring">                    FileAssetFetch::default().with_root("resources"),
</span><span class="boring">                )),
</span><span class="boring">            // Stored asset references for cached asset handles.
</span><span class="boring">            image_shader: AssetRef::new("shader://image.shader"),
</span><span class="boring">            ferris_texture: AssetRef::new("texture://ferris.png"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AppState&lt;Vertex&gt; for State {
</span><span class="boring">    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Setup scene camera.
</span><span class="boring">        graphics.color = [0.25, 0.25, 0.25, 1.0];
</span><span class="boring">        graphics.main_camera.screen_alignment = 0.5.into();
</span><span class="boring">        graphics.main_camera.scaling = CameraScaling::FitToView {
</span><span class="boring">            size: 1000.0.into(),
</span><span class="boring">            inside: false,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Load this scene group.
</span><span class="boring">        self.assets.ensure("group://ingame.txt").unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Process assets periotically.
</span><span class="boring">        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
</span><span class="boring">            self.timer = Instant::now();
</span><span class="boring">            self.process_assets(graphics);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Do not render unless we have shader loaded.
</span><span class="boring">        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">        let Some(image_shader) = image_shader
</span><span class="boring">            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
</span><span class="boring">            .map(|handle| handle.to_ref())
</span><span class="boring">        else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Begin drawing objects.
</span><span class="boring">        self.context.begin_frame(graphics);
</span><span class="boring">        self.context.push_shader(&amp;image_shader);
</span><span class="boring">        self.context.push_blending(GlowBlending::Alpha);
</span><span class="boring">
</span><span class="boring">        // Draw sprite only if texture asset is loaded.
</span><span class="boring">        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
</span><span class="boring">            if let Some(texture) = texture
</span><span class="boring">                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
</span><span class="boring">                .map(|handle| handle.to_ref())
</span><span class="boring">            {
</span><span class="boring">                Sprite::single(SpriteTexture::new("u_image".into(), texture))
</span><span class="boring">                    .pivot(0.5.into())
</span><span class="boring">                    .draw(&amp;mut self.context, graphics);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Commit drawn objects.
</span><span class="boring">        self.context.end_frame();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl State {
</span><span class="boring">    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">
</span><span class="boring">        // Process loaded shader assets into shader objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, ShaderAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
</span><span class="boring">            println!("* Shader asset turned into shader: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Process loaded texture assets into texture objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, TextureAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let texture = graphics
</span><span class="boring">                .texture(
</span><span class="boring">                    asset.width,
</span><span class="boring">                    asset.height,
</span><span class="boring">                    1,
</span><span class="boring">                    GlowTextureFormat::Rgba,
</span><span class="boring">                    Some(&amp;asset.bytes),
</span><span class="boring">                )
</span><span class="boring">                .unwrap();
</span><span class="boring">            println!("* Texture asset turned into texture: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        commands.execute(&amp;mut self.assets.storage);
</span><span class="boring">        self.assets.maintain().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Decoded shader asset information with dependencies.
</span><span class="boring">#[derive(Debug, Serialize, Deserialize)]
</span><span class="boring">struct ShaderAssetInfo {
</span><span class="boring">    vertex: AssetRef,
</span><span class="boring">    fragment: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset with vertex and fragment programs code.
</span><span class="boring">struct ShaderAsset {
</span><span class="boring">    vertex: String,
</span><span class="boring">    fragment: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
</span><span class="boring">struct ShaderAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
</span><span class="boring">    type Bundle = (ShaderAssetInfo,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
</span><span class="boring">        let vertex = asset.vertex.path().clone();
</span><span class="boring">        let fragment = asset.fragment.path().clone();
</span><span class="boring">
</span><span class="boring">        println!("* Shader asset processed: {asset:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((asset,))
</span><span class="boring">            .dependency(vertex)
</span><span class="boring">            .dependency(fragment))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();
</span><span class="boring">
</span><span class="boring">        // We scan for decoded shader info and if dependencies are loaded,
</span><span class="boring">        // then turn them into shader asset.
</span><span class="boring">        for (entity, info, dependencies) in
</span><span class="boring">            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
</span><span class="boring">        {
</span><span class="boring">            if dependencies
</span><span class="boring">                .entities()
</span><span class="boring">                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
</span><span class="boring">            {
</span><span class="boring">                let vertex = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">                let fragment = lookup
</span><span class="boring">                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
</span><span class="boring">                    .unwrap()
</span><span class="boring">                    .to_owned();
</span><span class="boring">
</span><span class="boring">                let asset = ShaderAsset { vertex, fragment };
</span><span class="boring">                commands.command(InsertCommand::new(entity, (asset,)));
</span><span class="boring">                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">        drop(lookup);
</span><span class="boring">
</span><span class="boring">        commands.execute(storage);
</span><span class="boring">
</span><span class="boring">        Ok(())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Decoded texture asset with its size and decoded bitmap bytes.
struct TextureAsset {
    width: u32,
    height: u32,
    bytes: Vec&lt;u8&gt;,
}

struct TextureAssetProcessor;

impl BundleWithDependenciesProcessor for TextureAssetProcessor {
    type Bundle = (TextureAsset,);

    fn process_bytes(
        &amp;mut self,
        bytes: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
        // Decode PNG image into texture size and bitmap bytes.
        let decoder = png::Decoder::new(bytes.as_slice());
        let mut reader = decoder.read_info()?;
        let mut buf = vec![0; reader.output_buffer_size()];
        let info = reader.next_frame(&amp;mut buf)?;
        let bytes = buf[..info.buffer_size()].to_vec();

        println!("* Texture asset processed: {info:#?}");
        Ok(BundleWithDependencies::new((TextureAsset {
            width: info.width,
            height: info.height,
            bytes,
        },)))
    }
}</code></pre>
<p>All we do here is we decode PNG image into texture decoded bytes along with
texture dimensions.</p>
<h2 id="shader-asset-processor"><a class="header" href="#shader-asset-processor">Shader asset processor</a></h2>
<p>Shader asset processor is a lot more interesting:</p>
<pre><code class="language-rust ignore"><span class="boring">use keket::{
</span><span class="boring">    database::{AssetDatabase, handle::AssetDependency, reference::AssetRef},
</span><span class="boring">    fetch::{deferred::DeferredAssetFetch, file::FileAssetFetch},
</span><span class="boring">    protocol::{
</span><span class="boring">        bundle::{BundleAssetProtocol, BundleWithDependencies, BundleWithDependenciesProcessor},
</span><span class="boring">        group::GroupAssetProtocol,
</span><span class="boring">        text::TextAssetProtocol,
</span><span class="boring">    },
</span><span class="boring">    third_party::anput::{
</span><span class="boring">        commands::{CommandBuffer, InsertCommand, RemoveCommand},
</span><span class="boring">        entity::Entity,
</span><span class="boring">        world::{Relation, World},
</span><span class="boring">    },
</span><span class="boring">};
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use spitfire::prelude::*;
</span><span class="boring">use std::{
</span><span class="boring">    error::Error,
</span><span class="boring">    sync::{Arc, RwLock},
</span><span class="boring">    time::Instant,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">    App::&lt;Vertex&gt;::default().run(State::default());
</span><span class="boring">
</span><span class="boring">    Ok(())
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">const DELTA_TIME: f32 = 1.0 / 60.0;
</span><span class="boring">
</span><span class="boring">struct State {
</span><span class="boring">    // We store drawing context for later use in app state.
</span><span class="boring">    // Drawing context holds resources and stack-based states.
</span><span class="boring">    context: DrawContext,
</span><span class="boring">    // Timer used for fixed step frame particle system simulation.
</span><span class="boring">    timer: Instant,
</span><span class="boring">    assets: AssetDatabase,
</span><span class="boring">    image_shader: AssetRef,
</span><span class="boring">    ferris_texture: AssetRef,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for State {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            context: Default::default(),
</span><span class="boring">            timer: Instant::now(),
</span><span class="boring">            assets: AssetDatabase::default()
</span><span class="boring">                // Text protocol for shader sources.
</span><span class="boring">                .with_protocol(TextAssetProtocol)
</span><span class="boring">                // Group protocol for loading many assets at once.
</span><span class="boring">                .with_protocol(GroupAssetProtocol)
</span><span class="boring">                // Custom shader protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("shader", ShaderAssetProcessor))
</span><span class="boring">                // Custom texture protocol.
</span><span class="boring">                .with_protocol(BundleAssetProtocol::new("texture", TextureAssetProcessor))
</span><span class="boring">                // Load all data from file system asynchronously.
</span><span class="boring">                .with_fetch(DeferredAssetFetch::new(
</span><span class="boring">                    FileAssetFetch::default().with_root("resources"),
</span><span class="boring">                )),
</span><span class="boring">            // Stored asset references for cached asset handles.
</span><span class="boring">            image_shader: AssetRef::new("shader://image.shader"),
</span><span class="boring">            ferris_texture: AssetRef::new("texture://ferris.png"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl AppState&lt;Vertex&gt; for State {
</span><span class="boring">    fn on_init(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Setup scene camera.
</span><span class="boring">        graphics.color = [0.25, 0.25, 0.25, 1.0];
</span><span class="boring">        graphics.main_camera.screen_alignment = 0.5.into();
</span><span class="boring">        graphics.main_camera.scaling = CameraScaling::FitToView {
</span><span class="boring">            size: 1000.0.into(),
</span><span class="boring">            inside: false,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Load this scene group.
</span><span class="boring">        self.assets.ensure("group://ingame.txt").unwrap();
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn on_redraw(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;, _: &amp;mut AppControl) {
</span><span class="boring">        // Process assets periotically.
</span><span class="boring">        if self.timer.elapsed().as_secs_f32() &gt; DELTA_TIME {
</span><span class="boring">            self.timer = Instant::now();
</span><span class="boring">            self.process_assets(graphics);
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Do not render unless we have shader loaded.
</span><span class="boring">        let Ok(image_shader) = self.image_shader.resolve(&amp;self.assets) else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">        let Some(image_shader) = image_shader
</span><span class="boring">            .access_checked::&lt;&amp;AsyncHandle&lt;Shader&gt;&gt;()
</span><span class="boring">            .map(|handle| handle.to_ref())
</span><span class="boring">        else {
</span><span class="boring">            return;
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        // Begin drawing objects.
</span><span class="boring">        self.context.begin_frame(graphics);
</span><span class="boring">        self.context.push_shader(&amp;image_shader);
</span><span class="boring">        self.context.push_blending(GlowBlending::Alpha);
</span><span class="boring">
</span><span class="boring">        // Draw sprite only if texture asset is loaded.
</span><span class="boring">        if let Ok(texture) = self.ferris_texture.resolve(&amp;self.assets) {
</span><span class="boring">            if let Some(texture) = texture
</span><span class="boring">                .access_checked::&lt;&amp;AsyncHandle&lt;Texture&gt;&gt;()
</span><span class="boring">                .map(|handle| handle.to_ref())
</span><span class="boring">            {
</span><span class="boring">                Sprite::single(SpriteTexture::new("u_image".into(), texture))
</span><span class="boring">                    .pivot(0.5.into())
</span><span class="boring">                    .draw(&amp;mut self.context, graphics);
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Commit drawn objects.
</span><span class="boring">        self.context.end_frame();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl State {
</span><span class="boring">    fn process_assets(&amp;mut self, graphics: &amp;mut Graphics&lt;Vertex&gt;) {
</span><span class="boring">        let mut commands = CommandBuffer::default();
</span><span class="boring">
</span><span class="boring">        // Process loaded shader assets into shader objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;ShaderAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, ShaderAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let shader = graphics.shader(&amp;asset.vertex, &amp;asset.fragment).unwrap();
</span><span class="boring">            println!("* Shader asset turned into shader: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(shader),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        // Process loaded texture assets into texture objects on GPU.
</span><span class="boring">        for entity in self.assets.storage.added().iter_of::&lt;TextureAsset&gt;() {
</span><span class="boring">            let asset = self
</span><span class="boring">                .assets
</span><span class="boring">                .storage
</span><span class="boring">                .component::&lt;true, TextureAsset&gt;(entity)
</span><span class="boring">                .unwrap();
</span><span class="boring">            let texture = graphics
</span><span class="boring">                .texture(
</span><span class="boring">                    asset.width,
</span><span class="boring">                    asset.height,
</span><span class="boring">                    1,
</span><span class="boring">                    GlowTextureFormat::Rgba,
</span><span class="boring">                    Some(&amp;asset.bytes),
</span><span class="boring">                )
</span><span class="boring">                .unwrap();
</span><span class="boring">            println!("* Texture asset turned into texture: {entity}");
</span><span class="boring">            commands.command(InsertCommand::new(entity, (AsyncHandle::new(texture),)));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        commands.execute(&amp;mut self.assets.storage);
</span><span class="boring">        self.assets.maintain().unwrap();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Workaround for GPU handles not being Send + Sync,
</span><span class="boring">// to be able to store them in assets database.
</span><span class="boring">struct AsyncHandle&lt;T: Clone&gt;(Arc&lt;RwLock&lt;T&gt;&gt;);
</span><span class="boring">
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Send for AsyncHandle&lt;T&gt; {}
</span><span class="boring">unsafe impl&lt;T: Clone&gt; Sync for AsyncHandle&lt;T&gt; {}
</span><span class="boring">
</span><span class="boring">impl&lt;T: Clone&gt; AsyncHandle&lt;T&gt; {
</span><span class="boring">    fn new(data: T) -&gt; Self {
</span><span class="boring">        Self(Arc::new(RwLock::new(data)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get(&amp;self) -&gt; T {
</span><span class="boring">        self.0.read().unwrap().clone()
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn to_ref(&amp;self) -&gt; ResourceRef&lt;T&gt; {
</span><span class="boring">        ResourceRef::object(self.get())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// Decoded shader asset information with dependencies.
#[derive(Debug, Serialize, Deserialize)]
struct ShaderAssetInfo {
    vertex: AssetRef,
    fragment: AssetRef,
}

// Shader asset with vertex and fragment programs code.
struct ShaderAsset {
    vertex: String,
    fragment: String,
}

// Shader asset processor that turns bytes -&gt; shader info -&gt; shader asset.
struct ShaderAssetProcessor;

impl BundleWithDependenciesProcessor for ShaderAssetProcessor {
    type Bundle = (ShaderAssetInfo,);

    fn process_bytes(
        &amp;mut self,
        bytes: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
        let asset = serde_json::from_slice::&lt;ShaderAssetInfo&gt;(&amp;bytes)?;
        let vertex = asset.vertex.path().clone();
        let fragment = asset.fragment.path().clone();

        println!("* Shader asset processed: {asset:#?}");
        Ok(BundleWithDependencies::new((asset,))
            .dependency(vertex)
            .dependency(fragment))
    }

    fn maintain(&amp;mut self, storage: &amp;mut World) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
        let mut commands = CommandBuffer::default();
        let mut lookup = storage.lookup_access::&lt;true, &amp;String&gt;();

        // We scan for decoded shader info and if dependencies are loaded,
        // then turn them into shader asset.
        for (entity, info, dependencies) in
            storage.query::&lt;true, (Entity, &amp;ShaderAssetInfo, &amp;Relation&lt;AssetDependency&gt;)&gt;()
        {
            if dependencies
                .entities()
                .all(|entity| storage.has_entity_component::&lt;String&gt;(entity))
            {
                let vertex = lookup
                    .access(storage.find_by::&lt;true, _&gt;(info.vertex.path()).unwrap())
                    .unwrap()
                    .to_owned();
                let fragment = lookup
                    .access(storage.find_by::&lt;true, _&gt;(info.fragment.path()).unwrap())
                    .unwrap()
                    .to_owned();

                let asset = ShaderAsset { vertex, fragment };
                commands.command(InsertCommand::new(entity, (asset,)));
                commands.command(RemoveCommand::&lt;(ShaderAssetInfo,)&gt;::new(entity));
            }
        }
        drop(lookup);

        commands.execute(storage);

        Ok(())
    }
}
<span class="boring">
</span><span class="boring">// Decoded texture asset with its size and decoded bitmap bytes.
</span><span class="boring">struct TextureAsset {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">    bytes: Vec&lt;u8&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct TextureAssetProcessor;
</span><span class="boring">
</span><span class="boring">impl BundleWithDependenciesProcessor for TextureAssetProcessor {
</span><span class="boring">    type Bundle = (TextureAsset,);
</span><span class="boring">
</span><span class="boring">    fn process_bytes(
</span><span class="boring">        &amp;mut self,
</span><span class="boring">        bytes: Vec&lt;u8&gt;,
</span><span class="boring">    ) -&gt; Result&lt;BundleWithDependencies&lt;Self::Bundle&gt;, Box&lt;dyn Error&gt;&gt; {
</span><span class="boring">        // Decode PNG image into texture size and bitmap bytes.
</span><span class="boring">        let decoder = png::Decoder::new(bytes.as_slice());
</span><span class="boring">        let mut reader = decoder.read_info()?;
</span><span class="boring">        let mut buf = vec![0; reader.output_buffer_size()];
</span><span class="boring">        let info = reader.next_frame(&amp;mut buf)?;
</span><span class="boring">        let bytes = buf[..info.buffer_size()].to_vec();
</span><span class="boring">
</span><span class="boring">        println!("* Texture asset processed: {info:#?}");
</span><span class="boring">        Ok(BundleWithDependencies::new((TextureAsset {
</span><span class="boring">            width: info.width,
</span><span class="boring">            height: info.height,
</span><span class="boring">            bytes,
</span><span class="boring">        },)))
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Since this asset is just a descriptor that holds references to dependencies such
as vertex anf fragment shader code, in asset processing we only schedule
dependency loading and then in <code>maintain</code> method we scan database storage for
<code>ShaderAssetInfo</code> component, along with dependency relations, and we test if all
dependencies are resolved (they are text assets so all should have <code>String</code>
component when complete). When all dependencies are complete, we can read them
and construct <code>ShaderAsset</code> with shader programs code for game to build GPU
shader objects.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
